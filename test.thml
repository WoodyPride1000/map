<!DOCTYPE html>
<html lang="ja">
<head>
    <title>OpenLayers çµ±åˆè¨ˆæ¸¬ãƒ»ä¼æ¬è¨ˆç®—ï¼ˆURLä¿®æ­£ç‰ˆï¼‰</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css">
    <style>
        /* å¿…é ˆï¼šåœ°å›³ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’å®šç¾© */
        #map {
            width: 100%;
            height: 100vh; /* åœ°å›³ã‚’ç”»é¢å…¨ä½“ã«è¡¨ç¤º */
        }
        
        /* --- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«/çµæœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å…±é€šã‚¹ã‚¿ã‚¤ãƒ« --- */
        .control-panel, .result-window {
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            font-family: sans-serif;
            transition: opacity 0.3s;
        }
        /* å¯å‹•ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .result-window {
            resize: both;
            overflow: auto;
            min-width: 250px;
            min-height: 100px;
            box-sizing: border-box;
            display: none;
        }
        .result-window-header {
            cursor: move;
            background-color: #f0f0f0;
            padding: 5px 15px;
            border-bottom: 1px solid #ccc;
            font-weight: bold;
            flex-shrink: 0;
        }

        /* --- 1. ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆ (å·¦ä¸‹) --- */
        #layer-switcher {
            left: 10px;
            bottom: 10px; 
            z-index: 1001; 
        }

        /* --- 2. ä¼æ¬è¨ˆç®—ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« (å³ä¸Š) --- */
        #propagation-controls {
            top: 10px; 
            right: 10px; 
            max-width: 280px;
        }
        #propagation-controls input[type="number"], #propagation-controls button {
            width: 80px;
            margin-left: 5px;
            margin-bottom: 5px;
        }
        #propagation-controls button {
            width: 100%;
            margin-left: 0;
        }
        #propagation-controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        #propagation-controls hr {
            margin: 8px 0;
        }
        #k-factor-select label {
            font-size: 1em;
            display: inline-flex;
            align-items: center;
        }

        /* --- 3. è¨ˆæ¸¬çµæœã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ (#popup) --- */
        #popup {
            right: 290px; 
            top: 10px;
            width: 330px; /* å¹…ã‚’å°‘ã—åºƒã’ãŸ */
            min-height: 180px;
        }
        #popup-content {
            padding: 15px;
            font-size: 0.95em;
        }
        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 5px;
            right: 8px;
            z-index: 10;
        }
        .ol-popup-closer:after {
            content: "âœ–";
        }
        
        /* --- 4. æ–­é¢å›³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ (#profile-popup) --- */
        #profile-popup {
            top: 40px; 
            left: 50px; 
            width: 500px; 
            height: 350px; 
            display: flex; 
            flex-direction: column;
            padding: 10px;
            z-index: 999;
        }
        #profile-popup-header {
            background-color: #e6f2ff;
            padding: 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #profile-closer {
            position: absolute;
            top: 5px;
            right: 8px;
            text-decoration: none;
            font-weight: bold;
            color: #333;
        }
        #profile-content {
            padding-top: 5px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }
        #elevationChart {
            width: 100% !important;
            flex-grow: 1;
            min-height: 100px;
            margin-bottom: 10px; 
        }
        #powerChart {
            width: 100% !important;
            flex-grow: 0; 
            min-height: 100px;
            max-height: 150px; 
        }
        #profile-status {
            flex-shrink: 0;
            padding-top: 5px;
            font-size: 0.9em;
        }
        
        /* ãã®ä»–ã‚¹ã‚¿ã‚¤ãƒ« */
        .los-yes { color: green; font-weight: bold; }
        .los-no { color: red; font-weight: bold; }
        .coord-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .coord-table th, .coord-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        .coord-table th {
            background-color: #f2f2f2;
        }
        .top-zindex {
            z-index: 1002 !important;
        }
        /* ä»°è§’è¡¨ç¤ºç”¨ã®å¼·èª¿ã‚¹ã‚¿ã‚¤ãƒ« */
        .elevation-angle {
            font-size: 1.1em;
            color: darkblue;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div id="profile-popup" class="result-window" role="dialog" aria-label="æ¨™é«˜æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="profile-popup-header" class="result-window-header" tabindex="0" aria-label="æ¨™é«˜æ–­é¢å›³ãƒ˜ãƒƒãƒ€ãƒ¼">æ¨™é«˜æ–­é¢å›³ / ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ </div>
        <a href="#" id="profile-closer" aria-label="æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0">âœ–</a>
        <div id="profile-content">
            <canvas id="elevationChart" aria-label="æ¨™é«˜æ–­é¢å›³"></canvas>
            <canvas id="powerChart" aria-label="ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ ï¼ˆé›»åŠ›ãƒ¬ãƒ™ãƒ«ï¼‰"></canvas>
            <div id="profile-status" aria-live="polite">2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...</div>
        </div>
    </div>
    
    <div id="popup" class="result-window" role="dialog" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="popup-header" class="result-window-header" tabindex="0" aria-label="è¨ˆæ¸¬çµæœãƒ˜ãƒƒãƒ€ãƒ¼">è¨ˆæ¸¬çµæœã¨ä¼æ¬è¨ˆç®—</div>
        <a href="#" id="popup-closer" class="ol-popup-closer" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0"></a>
        <div id="popup-content" aria-live="polite">åœ°å›³ä¸Šã®2ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚</div>
    </div>

    <div id="layer-switcher" class="control-panel">
        <div>ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="base_type" value="std" checked><span> æ¨™æº–ï¼ˆåœ°å›³ï¼‰</span></label><br>
        <label><input type="radio" name="base_type" value="photo"><span> å†™çœŸï¼ˆåœ°ç†é™¢ï¼‰</span></label><hr>
        <div>ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ</div>
        <div id="tile-source-options">
            <label><input type="radio" name="tile_source" value="osm" checked><span> OpenStreetMap</span></label><br>
            <label><input type="radio" name="tile_source" value="gsi"><span> å›½åœŸåœ°ç†é™¢ï¼ˆæ¨™æº–ï¼‰</span></label>
        </div>
    </div>
    
    <div id="propagation-controls" class="control-panel">
        <h4>å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            å‘¨æ³¢æ•° (MHz):
            <input type="number" id="freq-input" value="300" min="1" step="0.1">
        </label>
        <hr>
        
        <h4>åœ°çƒã®ä¸¸ã¿ (Kãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼)</h4>
        <div id="k-factor-select" style="display: flex; justify-content: space-around;">
            <label><input type="radio" name="k_factor" value="1/2"> 0.5 (æ–­)</label>
            <label><input type="radio" name="k_factor" value="4/3" checked> 4/3 (æ¨™æº–)</label>
            <label><input type="radio" name="k_factor" value="1"> 1.0 (ç›´ç·š)</label>
        </div>
        <hr>
        
        <h4>é€ä¿¡å´ (Tx) ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            Tx ç©ºä¸­ç·šé«˜ (m):
            <input type="number" id="tx-height-input" value="10" min="0" step="0.1">
        </label>
        <label>
            é€ä¿¡å‡ºåŠ› (W):
            <input type="number" id="tx-power-input" value="10" min="0.001" step="0.1">
        </label>
        <label>
            ç©ºä¸­ç·šåˆ©å¾— (dBi):
            <input type="number" id="tx-gain-input" value="10" step="0.1">
        </label>
        <label>
            ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹ (dB):
            <input type="number" id="tx-loss-input" value="4" min="0" step="0.1">
        </label>
        <hr>
        <h4>å—ä¿¡å´ (Rx) ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            Rx ç©ºä¸­ç·šé«˜ (m):
            <input type="number" id="rx-height-input" value="10" min="0" step="0.1">
        </label>
        <label>
            ç©ºä¸­ç·šåˆ©å¾— (dBi):
            <input type="number" id="rx-gain-input" value="10" step="0.1">
        </label>
        <label>
            ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹ (dB):
            <input type="number" id="rx-loss-input" value="4" min="0" step="0.1">
        </label>
        <hr>
        <div style="text-align: center; margin-bottom: 5px;">
            <strong style="font-size: 0.9em;">--- ã‚·ãƒŠãƒªã‚ªãƒ—ãƒªã‚»ãƒƒãƒˆ ---</strong>
        </div>
        <button class="preset-btn" data-scenario="marine">ğŸš¤ æµ·ä¸Šé€šä¿¡ (VHF/UHF)</button>
        <button class="preset-btn" data-scenario="urban">ğŸ™ï¸ éƒ½å¸‚å†… LTE (Sub-6)</button>
        <button class="preset-btn" data-scenario="longhaul">â›°ï¸ é•·è·é›¢ UHF/SHF</button>
        <hr>
        <button id="simple-recalculate-btn">ä¼æ¬è¨ˆç®—å®Ÿè¡Œ (Two-Rayåˆ‡æ›¿)</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mgrs@1.0.0/dist/mgrs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // å®šæ•°å®šç¾©
        const ELEVATION_API_URL = 'https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php';
        const DEFAULT_PROFILE_STEPS = 50; 
        const API_TIMEOUT_MS = 5000;
        const PROJ_WGS84 = "EPSG:4326";
        const EARTH_RADIUS_M = 6371000; 
        const W_TO_DBM = (W) => 10 * Math.log10(W * 1000);
        const elevationCache = new Map();
        
        // ãƒ—ãƒªã‚»ãƒƒãƒˆå®šç¾©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ (å¤‰æ›´ãªã—)
        const PRESETS = {
            marine: {
                freq: 150, txHeight: 15, rxHeight: 3, txPower: 25, txGain: 5, rxGain: 5, txLoss: 2, rxLoss: 2,
                name: "æµ·ä¸Šé€šä¿¡ (VHF/UHF)"
            },
            urban: {
                freq: 2600, txHeight: 30, rxHeight: 2, txPower: 5, txGain: 15, rxGain: 1, txLoss: 3, rxLoss: 1,
                name: "éƒ½å¸‚å†… LTE (Sub-6)"
            },
            longhaul: {
                freq: 900, txHeight: 50, rxHeight: 10, txPower: 100, txGain: 18, rxGain: 18, txLoss: 5, rxLoss: 5,
                name: "é•·è·é›¢ UHF/SHF ãƒªãƒ³ã‚¯"
            }
        };
        const INITIAL_PARAMS = {
            freq: 300, txHeight: 10, rxHeight: 10, txPower: 10, txGain: 10, rxGain: 10, txLoss: 4, rxLoss: 4
        };

        // K-Factorã®å€¤ã‚’DOMã‹ã‚‰å–å¾—ã™ã‚‹é–¢æ•° (å¤‰æ›´ãªã—)
        function getCurrentKFactor() {
            const selectedK = document.querySelector('input[name="k_factor"]:checked').value;
            if (selectedK === "4/3") return 4 / 3;
            if (selectedK === "1/2") return 0.5;
            return 1.0; 
        }

        // UTM/MGRSå¤‰æ›é–¢æ•° (å¤‰æ›´ãªã—)
        function getUtmProjDef(lon) {
            const zoneNum = Math.floor((lon + 180) / 6) % 60 + 1;
            const north = (lon >= 0) ? 'north' : 'south';
            // æ—¥æœ¬ã¯UTM Zone 51, 52, 53, 54 North (N) ã«ã¾ãŸãŒã‚‹
            const projString = `+proj=utm +zone=${zoneNum} +${north} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
            // proj4.defsã¸ã®è¿½åŠ ã¯ã€å¿…è¦ã«å¿œã˜ã¦è¡Œã†
            if (!proj4.defs(`EPSG:utm-zone-${zoneNum}${north.charAt(0).toUpperCase()}`)) {
                 proj4.defs(`EPSG:utm-zone-${zoneNum}${north.charAt(0).toUpperCase()}`, projString);
            }
            return `EPSG:utm-zone-${zoneNum}${north.charAt(0).toUpperCase()}`;
        }
        function convertToUTM(lonLat) {
             try {
                const projCode = getUtmProjDef(lonLat[0]);
                const utmCoord = proj4(PROJ_WGS84, projCode, lonLat);
                const zoneCode = projCode.split('-')[2]; 
                return `${utmCoord[0].toFixed(2)}m E, ${utmCoord[1].toFixed(2)}m N (${zoneCode})`;
            } catch (e) {
                return "N/A (UTM error)";
            }
        }
        function convertToMGRS(lonLat, precision = 4) { 
             try {
                return mgrs.forward(lonLat, precision);
            } catch (e) {
                return "N/A (MGRS error)";
            }
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾©ã®ä¿®æ­£
        const osmLayer = new ol.layer.Tile({ title: 'OpenStreetMap', type: 'base', visible: true, source: new ol.source.OSM() });
        
        // GSI æ¨™æº–åœ°å›³ã®URLã‚’æ¨å¥¨ã•ã‚Œã‚‹å½¢å¼ã«ä¿®æ­£ (ä¸€éƒ¨ã®ç’°å¢ƒã§cyberjapandata2ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚)
        const gsiStdLayer = new ol.layer.Tile({ 
            title: 'GSI_Standard', 
            type: 'base', 
            visible: false, 
            source: new ol.source.XYZ({ 
                url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', 
                attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' 
            }) 
        });
        
        // GSI å†™çœŸåœ°å›³ã®URLã‚’ä¿®æ­£ (PNGã«åˆ‡ã‚Šæ›¿ãˆã€ã¾ãŸã¯ã‚µãƒ–ãƒ‰ãƒ¡ã‚¤ãƒ³ã‚’å¤‰æ›´)
        const gsiPhotoLayer = new ol.layer.Tile({ 
            title: 'GSI_Photo', 
            type: 'base', 
            visible: false, 
            source: new ol.source.XYZ({ 
                // seamlessphotoã®æ¨å¥¨URLã¯.jpgã§ã™ãŒã€ä¸€éƒ¨ç’°å¢ƒã§ã®ã‚¨ãƒ©ãƒ¼å›é¿ã®ãŸã‚ã€ã“ã¡ã‚‰ã‚’è©¦ã—ã¾ã™ã€‚
                url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', 
                attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' 
            }) 
        });

        // âš ï¸ ä¸Šè¨˜URLã§ã‚¨ãƒ©ãƒ¼ãŒè§£æ±ºã—ãªã„å ´åˆã€URLã‚’ä»¥ä¸‹ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚
        /*
        const gsiPhotoLayer = new ol.layer.Tile({ 
            // URLã‚’http://maps.gsi.go.jpã«ä¸€æ™‚çš„ã«åˆ‡ã‚Šæ›¿ãˆã‚‹
            url: 'https://maps.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', 
            attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' 
        });
        */


        const baseLayerGroup = new ol.layer.Group({ layers: [osmLayer, gsiStdLayer, gsiPhotoLayer] }); 
        
        let points = [];
        
        const vectorSource = new ol.source.Vector();
        const lineStyle = new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 255, 0.7)', width: 4, lineDash: [10, 5] }) });
        const maxElevStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'orange' }), stroke: new ol.style.Stroke({ color: 'black', width: 3 }) }) });
        const pointStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({ color: 'red' }), stroke: new ol.style.Stroke({ color: 'white', width: 2 }) }) });
        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.get('type') === 'max_elevation') return maxElevStyle;
                if (feature.getGeometry().getType() === 'LineString') return lineStyle;
                return pointStyle;
            }
        });

        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');
        const popupHeader = document.getElementById('popup-header'); 
        const profileHeader = document.getElementById('profile-popup-header'); 

        // åœ°å›³ã®åˆæœŸåŒ– (å¤‰æ›´ãªã—)
        const map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, vectorLayer],
            view: new ol.View({
                center: ol.proj.fromLonLat([139.75, 35.68]),
                zoom: 12,
                maxZoom: 18
            })
        });

        let elevationChart = null; 
        let powerChart = null;      

        // --- ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ (å¤‰æ›´ãªã—) ---
        let isDragging = false;
        let startPoint; 
        let startPosition; 
        let currentDraggingElement = null;

        function startDrag(event, targetElement) {
            const validHeader = event.target.closest('.result-window-header');
            if (!validHeader) return;
            const isTouchEvent = event.type.includes('touch');
            if (!isTouchEvent && event.button !== 0) return; 

            event.preventDefault(); 
            event.stopPropagation();
            
            const style = window.getComputedStyle(targetElement);
            if (style.cursor.includes('resize')) return; 

            isDragging = true;
            currentDraggingElement = targetElement;
            currentDraggingElement.classList.add('top-zindex');
            
            const eventPoint = isTouchEvent ? [event.touches[0].clientX, event.touches[0].clientY] : [event.clientX, event.clientY];
            startPoint = eventPoint;
            
            const rect = targetElement.getBoundingClientRect();
            targetElement.style.right = 'auto';
            targetElement.style.bottom = 'auto';
            targetElement.style.left = `${rect.left}px`;
            targetElement.style.top = `${rect.top}px`;
            
            startPosition = [rect.left, rect.top];

            map.getInteractions().forEach(interaction => interaction.setActive(false));
        }

        function handleDragMove(event) {
            if (!isDragging || !currentDraggingElement) return;
            const isTouchEvent = event.type.includes('touch');
            if (isTouchEvent) event.preventDefault();

            const currentPoint = isTouchEvent ? [event.touches[0].clientX, event.touches[0].clientY] : [event.clientX, event.clientY];
            const deltaX = currentPoint[0] - startPoint[0];
            const deltaY = currentPoint[1] - startPoint[1];
            
            const newLeft = startPosition[0] + deltaX;
            const newTop = startPosition[1] + deltaY;

            const mapContainer = map.getTargetElement();
            const mapRect = mapContainer.getBoundingClientRect();
            const elWidth = currentDraggingElement.offsetWidth;
            const elHeight = currentDraggingElement.offsetHeight;
            
            const finalLeft = Math.max(0, Math.min(newLeft, mapRect.width - elWidth));
            const finalTop = Math.max(0, Math.min(newTop, mapRect.height - elHeight));

            currentDraggingElement.style.left = `${finalLeft}px`;
            currentDraggingElement.style.top = `${finalTop}px`;
        }

        function stopDrag() {
            if (isDragging) {
                if (currentDraggingElement) {
                    currentDraggingElement.classList.remove('top-zindex');
                }
                isDragging = false;
                currentDraggingElement = null;
                map.getInteractions().forEach(interaction => interaction.setActive(true));
            }
        }
        // --- /ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ ---

        // å…±é€šé–¢æ•° (å¤‰æ›´ãªã—)
        function resetParameters() {
            document.getElementById('freq-input').value = INITIAL_PARAMS.freq;
            document.getElementById('tx-height-input').value = INITIAL_PARAMS.txHeight;
            document.getElementById('rx-height-input').value = INITIAL_PARAMS.rxHeight;
            document.getElementById('tx-power-input').value = INITIAL_PARAMS.txPower;
            document.getElementById('tx-gain-input').value = INITIAL_PARAMS.txGain;
            document.getElementById('rx-gain-input').value = INITIAL_PARAMS.rxGain;
            document.getElementById('tx-loss-input').value = INITIAL_PARAMS.txLoss;
            document.getElementById('rx-loss-input').value = INITIAL_PARAMS.rxLoss;
        }
        
        // ãƒ—ãƒªã‚»ãƒƒãƒˆã‚’é©ç”¨ã™ã‚‹é–¢æ•° (å¤‰æ›´ãªã—)
        function applyPreset(scenario) {
            const params = PRESETS[scenario];
            if (!params) return;

            document.getElementById('freq-input').value = params.freq;
            document.getElementById('tx-height-input').value = params.txHeight;
            document.getElementById('rx-height-input').value = params.rxHeight;
            document.getElementById('tx-power-input').value = params.txPower;
            document.getElementById('tx-gain-input').value = params.txGain;
            document.getElementById('rx-gain-input').value = params.rxGain;
            document.getElementById('tx-loss-input').value = params.txLoss;
            document.getElementById('rx-loss-input').value = params.rxLoss;
            
            if (window.lastProfile) {
                profileStatus.textContent = `${params.name} ãƒ—ãƒªã‚»ãƒƒãƒˆãŒé©ç”¨ã•ã‚Œã¾ã—ãŸã€‚ã€Œä¼æ¬è¨ˆç®—å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦æ›´æ–°ã—ã¦ãã ã•ã„ã€‚`;
            }
        }

        function resetMeasurement() { 
            vectorSource.clear(); 
            points = [];
            if (elevationChart) { elevationChart.destroy(); elevationChart = null; } 
            if (powerChart) { powerChart.destroy(); powerChart = null; } 
            
            profileContainer.style.display = 'none'; 
            container.style.display = 'none'; 
            profileStatus.textContent = '2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...';
            content.innerHTML = 'åœ°å›³ä¸Šã®2ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚'; 
            
            resetParameters();

            window.lastProfile = null; 
            window.lastDistance = null;
            window.lastMaxElevation = null;
        }
        
        /**
         * drawElevationChart (åœ°è¡¨ãŒä¸Šå‘ãå††å¼§ã®ã‚°ãƒ©ãƒ•ç‰ˆ) - å¤‰æ›´ãªã—
         */
        function drawElevationChart(profile, distanceMeters) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            const txHeightM = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeightM = parseFloat(document.getElementById('rx-height-input').value);
            const freqMHz = parseFloat(document.getElementById('freq-input').value);
            
            const K_FACTOR = getCurrentKFactor();
            const effectiveEarthRadiusM = EARTH_RADIUS_M * K_FACTOR;
            
            const txGroundElev = profile[0].elevation;
            const rxGroundElev = profile[profile.length - 1].elevation;
            const txAbsElev = txGroundElev + txHeightM;
            const rxAbsElev = rxGroundElev + rxHeightM;
            const labels = profile.map(p => (p.distance / 1000).toFixed(2));
            
            // ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã‚’ã€Œçµ¶å¯¾çš„ãªé«˜ã•ã€ã§ä½œæˆ
            const elevationsArc = [];      // åœ°å½¢æ¨™é«˜ (çµ¶å¯¾é«˜ã•)
            const losLineArc = [];         // è¦‹é€šã—ç·š (çµ¶å¯¾é«˜ã• - ç›´ç·š)
            const f0_6LowerArc = [];       // 0.6F1ä¸‹é™ (çµ¶å¯¾é«˜ã• - æ›²ç·š)
            const arcBaseLine = [];        // åœ°è¡¨ã®å††å¼§ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ (ä¸Šå‘ãæ›²ç‡)

            profile.forEach(p => {
                const d1 = p.distance;
                const d2 = distanceMeters - d1;
                
                // åœ°çƒã®è†¨ã‚‰ã¿ï¼ˆãƒãƒ«ã‚¸ï¼‰: Kãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã‚’é©ç”¨ã—ãŸæ›²ç‡
                const bulgeCorrection = (d1 * d2) / (2 * effectiveEarthRadiusM);
                
                // Txã¨Rxã®åœ°è¡¨æ¨™é«˜ã‚’çµã¶ç›´ç·š
                const groundLineHeight = txGroundElev + (rxGroundElev - txGroundElev) * (d1 / distanceMeters);

                // (1) å††å¼§ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³: åœ°è¡¨ç›´ç·š - ãƒãƒ«ã‚¸è£œæ­£ (ä¸Šå‘ãã®å††å¼§)
                arcBaseLine.push(groundLineHeight - bulgeCorrection);

                // (2) åœ°å½¢æ¨™é«˜: æ¨™é«˜ã¯çµ¶å¯¾å€¤ã§æãã€ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã«å¯¾ã™ã‚‹ç›¸å¯¾çš„ãªé«˜ã•ã¨ã™ã‚‹
                elevationsArc.push(p.elevation);

                // (3) è¦‹é€šã—ç·š (Tx/Rxã‚¢ãƒ³ãƒ†ãƒŠã‚’çµã¶ç›´ç·š)
                const losAbsHeight = txAbsElev + (rxAbsElev - txAbsElev) * (d1 / distanceMeters);
                losLineArc.push(losAbsHeight);
                
                // (4) 0.6F1ä¸‹é™: LOSãƒ©ã‚¤ãƒ³ã‹ã‚‰ãƒ•ãƒ¬ãƒãƒ«ã‚¾ãƒ¼ãƒ³ã‚’å¼•ã
                const f1Radius = 17.32 * Math.sqrt((d1 * d2) / (freqMHz * distanceMeters)); 
                f0_6LowerArc.push(losAbsHeight - (0.6 * f1Radius)); 
            });

            // ã‚°ãƒ©ãƒ•ã®Yè»¸ã®ç¯„å›²è¨­å®š
            const allY = [...elevationsArc, ...losLineArc, ...f0_6LowerArc, ...arcBaseLine].filter(v => !isNaN(v));
            const minY = Math.min(...allY);
            const maxY = Math.max(...allY);

            const data = {
                labels: labels,
                datasets: [
                    {
                        label: 'åœ°å½¢æ¨™é«˜ (çµ¶å¯¾é«˜)',
                        data: elevationsArc,
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: 'start', 
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4,
                        order: 3
                    },
                    {
                        label: 'åœ°è¡¨å††å¼§ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³',
                        data: arcBaseLine,
                        borderColor: 'rgba(100, 100, 100, 0.5)',
                        backgroundColor: 'transparent',
                        borderWidth: 1,
                        pointRadius: 0,
                        tension: 0.4,
                        order: 4
                    },
                    {
                        label: 'Tx/Rx LOS (ç›´ç·š)',
                        data: losLineArc,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        tension: 0,
                        order: 1
                    },
                    {
                        label: '0.6F1ä¸‹é™',
                        data: f0_6LowerArc,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0,
                        order: 2
                    }
                ]
            };
            
            const kFactorDisplay = K_FACTOR.toFixed(3); 

            if (elevationChart) {
                elevationChart.data = data;
                elevationChart.options.scales.x.title.text = `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km`;
                elevationChart.options.scales.y.min = Math.floor(minY / 10) * 10 - 20; 
                elevationChart.options.scales.y.max = Math.ceil(maxY / 10) * 10 + 20;
                elevationChart.options.plugins.title.text = `é›»æ³¢ä¼æ¬ç”¨ å††å¼§æ–­é¢å›³ (åœ°è¡¨ä¸Šå‘ã, K=${kFactorDisplay})`;
                elevationChart.update();
            } else {
                elevationChart = new Chart(ctx, {
                    type: 'line',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { title: { display: true, text: `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km` } },
                            y: { 
                                title: { display: true, text: 'çµ¶å¯¾æ¨™é«˜ (m)' }, 
                                beginAtZero: false,
                                min: Math.floor(minY / 10) * 10 - 20, 
                                max: Math.ceil(maxY / 10) * 10 + 20
                            }
                        },
                        plugins: { 
                            legend: { display: true, position: 'top' }, 
                            title: { display: true, text: `é›»æ³¢ä¼æ¬ç”¨ å††å¼§æ–­é¢å›³ (åœ°è¡¨ä¸Šå‘ã, K=${kFactorDisplay})` } 
                        }
                    }
                });
            }
        }
        
        // drawPowerChart (å¤‰æ›´ãªã—)
        function drawPowerChart(propResults) {
            const ctx = document.getElementById('powerChart').getContext('2d');
            const txPowerW = parseFloat(document.getElementById('tx-power-input').value);
            const txGainDbi = parseFloat(document.getElementById('tx-gain-input').value);
            const rxGainDbi = parseFloat(document.getElementById('rx-gain-input').value);
            const txLossDb = parseFloat(document.getElementById('tx-loss-input').value);
            const rxLossDb = parseFloat(document.getElementById('rx-loss-input').value);
            
            if (propResults.error) {
                if (powerChart) powerChart.destroy(); powerChart = null;
                return;
            }

            const txPowerDbm = W_TO_DBM(txPowerW); 
            const afterTxLoss = txPowerDbm - txLossDb; 
            const eirpDbm = afterTxLoss + txGainDbi; 
            const afterPropLoss = eirpDbm - propResults.totalLossDb; 
            const afterRxGain = afterPropLoss + rxGainDbi; 
            const rxPowerDbm = afterRxGain - rxLossDb; 

            const labels = [
                'é€ä¿¡æ©Ÿå‡ºåŠ›', 'Txã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹', 'Txç©ºä¸­ç·šåˆ©å¾— (EIRP)', 
                'ä¼æ¬æå¤± (Rxã‚¢ãƒ³ãƒ†ãƒŠå…¥åŠ›)', 'Rxç©ºä¸­ç·šåˆ©å¾—', 'Rxã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹', 'å—ä¿¡é›»åŠ›'
            ];

            const dataPoints = [
                txPowerDbm, afterTxLoss, eirpDbm, afterPropLoss, afterRxGain, rxPowerDbm, rxPowerDbm        
            ];

            const data = {
                labels: labels,
                datasets: [{
                    label: 'é›»åŠ›ãƒ¬ãƒ™ãƒ« (dBm)',
                    data: dataPoints,
                    type: 'line',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.5)',
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                    fill: false,
                    tension: 0 
                }]
            };

            if (powerChart) {
                powerChart.data = data;
                const minVal = Math.min(...dataPoints);
                const maxVal = Math.max(...dataPoints);
                powerChart.options.scales.y.min = Math.floor(minVal / 10) * 10 - 10;
                powerChart.options.scales.y.max = Math.ceil(maxVal / 10) * 10 + 10;
                
                powerChart.update();
            } else {
                powerChart = new Chart(ctx, {
                    type: 'line', 
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { 
                                title: { display: true, text: 'ä¼æ¬çµŒè·¯ä¸Šã®è¦ç´ ' }, 
                                grid: { display: false } 
                            },
                            y: { 
                                title: { display: true, text: 'é›»åŠ›ãƒ¬ãƒ™ãƒ« (dBm)' }, 
                                beginAtZero: false 
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: 'ä¼æ¬çµŒè·¯ ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ ', font: { size: 14 } },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2) + ' dBm';
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            profileStatus.textContent = `${propResults.lossType.split('(')[0].trim()}è¨ˆç®—å®Œäº†ã€‚å—ä¿¡é›»åŠ›: ${rxPowerDbm.toFixed(2)} dBm`;
        }

        // æ¨™é«˜ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ (å¤‰æ›´ãªã—)
        async function getElevation(coordinate) {
            const cacheKey = coordinate.map(c => c.toFixed(5)).join(',');
            if (elevationCache.has(cacheKey)) return elevationCache.get(cacheKey);

            const [lon, lat] = coordinate;
            const url = `${ELEVATION_API_URL}?lon=${lon}&lat=${lat}`;

            try {
                const response = await fetch(url, { signal: AbortSignal.timeout(API_TIMEOUT_MS) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                
                let elevation = data.elevation !== null && data.elevation !== undefined ? parseFloat(data.elevation) : 0;
                
                elevationCache.set(cacheKey, elevation);
                return elevation;
            } catch (e) {
                console.warn(`Failed to fetch elevation for ${cacheKey}: ${e.message}. Using 0m.`);
                
                elevationCache.set(cacheKey, 0);
                return 0;
            }
        }
        function interpolateCoordinates(coordA, coordB, fraction) {
            const lon = coordA[0] + (coordB[0] - coordA[0]) * fraction;
            const lat = coordA[1] + (coordB[1] - coordA[1]) * fraction;
            return [lon, lat];
        }

        async function getElevationProfile(coord1, coord2, maxSteps = DEFAULT_PROFILE_STEPS) { 
            const distanceMeters = ol.sphere.getDistance(coord1, coord2);
            const steps = Math.max(10, Math.min(maxSteps, Math.ceil(distanceMeters / 100)));
            const profile = [];
            for (let i = 0; i <= steps; i++) { 
                const fraction = i / steps;
                const coord = interpolateCoordinates(coord1, coord2, fraction);
                const elevation = await getElevation(coord); 
                profile.push({ coord, webMercatorCoord: ol.proj.fromLonLat(coord), elevation, distance: distanceMeters * fraction });
            }
            return profile;
        }
        function findMaxElevationPoint(profile) { 
            if (!profile || profile.length === 0) return null;
            let maxElev = -Infinity;
            let maxPoint = null;
            for (const p of profile) {
                if (p.elevation !== null && p.elevation > maxElev) {
                    maxElev = p.elevation;
                    maxPoint = p;
                }
            }
            return maxPoint;
        }
        function addPointFeature(webMercatorCoord) {
            vectorSource.addFeature(new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord) }));
        }

        /**
         * ä»°ä¿¯è§’ï¼ˆã‚¨ãƒ¬ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ³ã‚°ãƒ«ï¼‰è¨ˆç®—é–¢æ•° (å¤‰æ›´ãªã—)
         */
        function calculateElevationAngle(h1, h2, D, R_eff) {
            if (D === 0) return 0;
            
            // åœ°çƒã®ä¸¸ã¿ã«ã‚ˆã‚‹è£œæ­£é …
            const curvatureCorrection = (D * D) / (2 * R_eff);
            
            // ä¿®æ­£åœ°çƒæ–­é¢å›³ã«ãŠã‘ã‚‹Rxã®é«˜ã• (h2' = h2 - h1 - curvatureCorrection)
            const h2_prime = h2 - h1 - curvatureCorrection;
            
            // è§’åº¦ã‚’è¨ˆç®— (ãƒ©ã‚¸ã‚¢ãƒ³)
            const angleRad = Math.atan(h2_prime / D);
            
            // åº¦ã«å¤‰æ›ã—ã¦è¿”ã™ (æ­£ãŒä»°è§’ã€è² ãŒä¿¯è§’)
            return angleRad * (180 / Math.PI);
        }

        /**
         * ä¼æ¬æå¤±ã®è¨ˆç®—ã¨ä»°ä¿¯è§’è¨ˆç®—ã®çµ±åˆ (å¤‰æ›´ãªã—)
         */
        function calculatePropagation(profile, distanceMeters) { 
            if (!profile || profile.length < 2) return { los: false, freespaceLoss: NaN, clearance: NaN, rxPowerDbm: NaN, totalLossDb: NaN, error: "ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ä¸è¶³" };
            
            const freqMHz = parseFloat(document.getElementById('freq-input').value);
            const txHeightM = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeightM = parseFloat(document.getElementById('rx-height-input').value);
            const txPowerW = parseFloat(document.getElementById('tx-power-input').value);
            const txGainDbi = parseFloat(document.getElementById('tx-gain-input').value);
            const rxGainDbi = parseFloat(document.getElementById('rx-gain-input').value);
            const txLossDb = parseFloat(document.getElementById('tx-loss-input').value);
            const rxLossDb = parseFloat(document.getElementById('rx-loss-input').value);
            
            if (isNaN(freqMHz) || isNaN(txHeightM) || isNaN(rxHeightM) || isNaN(txPowerW) || isNaN(txGainDbi) || isNaN(rxGainDbi) || isNaN(txLossDb) || isNaN(rxLossDb)) {
                 return { los: false, freespaceLoss: NaN, clearance: NaN, rxPowerDbm: NaN, totalLossDb: NaN, error: "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™" };
            }
            
            const K_FACTOR = getCurrentKFactor();
            const effectiveEarthRadiusM = EARTH_RADIUS_M * K_FACTOR;

            const distKm = distanceMeters / 1000;
            const freespaceLossDb = 20 * Math.log10(distKm) + 20 * Math.log10(freqMHz) + 32.44;
            const txPowerDbm = W_TO_DBM(txPowerW);
            const eirpDbm = txPowerDbm - txLossDb + txGainDbi;
            
            let totalLossDb = freespaceLossDb;
            
            let minMarginMeters = Infinity; 
            let minLosClearanceH = Infinity; 
            let minV = Infinity; 
            let deepestObstructionPoint = null; 
            
            const txGroundElev = profile[0].elevation;
            const rxGroundElev = profile[profile.length - 1].elevation;
            const txAbsElev = txGroundElev + txHeightM;
            const rxAbsElev = rxGroundElev + rxHeightM;
            const wavelength = 300 / freqMHz * 1000000 / 1000000;
            
            // --- ä»°ä¿¯è§’ã®è¨ˆç®— ---
            const txToRxAngleDeg = calculateElevationAngle(txAbsElev, rxAbsElev, distanceMeters, effectiveEarthRadiusM);
            const rxToTxAngleDeg = calculateElevationAngle(rxAbsElev, txAbsElev, distanceMeters, effectiveEarthRadiusM);


            // --- çµŒè·¯åˆ†æã¨æå¤±è¨ˆç®— ---
            
            const isAllZeroElevation = profile.every(p => p.elevation !== null && p.elevation <= 0.1); 
            
            if (isAllZeroElevation) {
                const rxPowerDbm = eirpDbm - freespaceLossDb + rxGainDbi - rxLossDb;
                return {
                    los: true, ad_loss: 0, minMarginMeters: Infinity, freespaceLossDb: freespaceLossDb, totalLossDb: freespaceLossDb,
                    txPowerDbm: txPowerDbm, rxPowerDbm: rxPowerDbm, lossType: "è‡ªç”±ç©ºé–“æå¤± (FSPL) - æµ·ä¸Šè£œæ­£ âš“",
                    txAngle: txToRxAngleDeg, rxAngle: rxToTxAngleDeg 
                };
            }

            for (let i = 1; i < profile.length - 1; i++) {
                const p = profile[i];
                if (p.elevation === null) continue; 

                const d1 = p.distance; 
                const d2 = distanceMeters - d1; 
                
                const bulge = (d1 * d2) / (2 * effectiveEarthRadiusM);
                const obstacleHeight = p.elevation - bulge; 
                const losHeight = txAbsElev + (rxAbsElev - txAbsElev) * (d1 / distanceMeters) - bulge; 
                const clearanceH = losHeight - obstacleHeight; 
                
                minLosClearanceH = Math.min(minLosClearanceH, clearanceH); 
                
                const f1Radius = 17.32 * Math.sqrt((d1 * d2) / (freqMHz * distanceMeters)); 
                minMarginMeters = Math.min(minMarginMeters, clearanceH - f1Radius);

                if (d1 > 0 && d2 > 0 && distanceMeters > 0) {
                    const v = clearanceH * Math.sqrt(2 / wavelength * (1/d1 + 1/d2));
                    if (v < minV) {
                        minV = v;
                        deepestObstructionPoint = { v, d1, d2, clearanceH, f1Radius };
                    }
                }
            }
            
            const los = (minLosClearanceH > -0.01); 
            let ad_loss = 0; 
            let lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";

            // ä¼æ¬ãƒ¢ãƒ‡ãƒ«ã®æ¡ä»¶åˆ†å²ï¼ˆå¤‰æ›´ãªã—ï¼‰
            if (deepestObstructionPoint) {
                const v = deepestObstructionPoint.v;
                
                if (v >= 0.6) { 
                    const h_t_eff = txHeightM;
                    const h_r_eff = rxHeightM;
                    
                    const twoRayLossDb = 40 * Math.log10(distanceMeters) 
                                       - 20 * Math.log10(h_t_eff) 
                                       - 20 * Math.log10(h_r_eff) 
                                       + 20 * Math.log10(wavelength)
                                       - 20 * Math.log10(4 * Math.PI);

                    if (twoRayLossDb > freespaceLossDb) {
                        totalLossDb = twoRayLossDb;
                        ad_loss = twoRayLossDb - freespaceLossDb; 
                        lossType = `Two-Ray Model Loss (Two-Ray) âœ¨`;
                    } else {
                        ad_loss = 0;
                        lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";
                    }
                    
                } else if (v < 0) {
                    if (v >= -0.78) {
                        ad_loss = 6.9 + 20 * Math.log10(Math.sqrt(Math.pow(v - 0.1, 2) + 1) + v - 0.1);
                    } else {
                        ad_loss = 20 + 20 * (Math.abs(v) - 0.78); 
                        ad_loss = Math.min(ad_loss, 100); 
                    }
                    ad_loss = Math.max(0, ad_loss); 
                    totalLossDb += ad_loss; 
                    lossType = `ITU-R P.526 å›æŠ˜æå¤± (P.526) ğŸš§`;

                } else { 
                     ad_loss = 0;
                     lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";
                }
            } else {
                ad_loss = 0; 
                lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";
            }
            
            const rxPowerDbm = eirpDbm - totalLossDb + rxGainDbi - rxLossDb;

            return {
                los: los, ad_loss: ad_loss, 
                minClearanceRatio: minMarginMeters / deepestObstructionPoint?.f1Radius || NaN,
                minMarginMeters: minMarginMeters, freespaceLossDb: freespaceLossDb,
                totalLossDb: totalLossDb, txPowerDbm: txPowerDbm, rxPowerDbm: rxPowerDbm,
                lossType: lossType,
                txAngle: txToRxAngleDeg, 
                rxAngle: rxToTxAngleDeg  
            };
        }

        /**
         * è¨ˆæ¸¬çµæœã®è¡¨ç¤º (å¤‰æ›´ãªã—)
         */
        function displayMeasurementResults(coord1, coord2, dist, elev1, elev2, maxPoint, propResults = null) {
            const txHeight = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeight = parseFloat(document.getElementById('rx-height-input').value);

            let propHtml = '<h4>ä¼æ¬è¨ˆç®—çµæœ</h4><p>ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€ã€Œä¼æ¬è¨ˆç®—å®Ÿè¡Œ (Two-Rayåˆ‡æ›¿)ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>';
            let losClass = '';
            
            // --- åº§æ¨™å¤‰æ›ã®å¾©å…ƒ ---
            const txMgrs = convertToMGRS(coord1);
            const rxMgrs = convertToMGRS(coord2);
            const txUtm = convertToUTM(coord1);
            const rxUtm = convertToUTM(coord2);
            // ------------------------

            if (propResults && !propResults.error) {
                
                losClass = propResults.los ? 'los-yes' : 'los-no';
                const losText = propResults.los ? 'è¦‹é€šã—ã‚ã‚Š (LOS)' : 'è¦‹é€šã—ãªã— (NLOS)';

                const marginMeters = propResults.minMarginMeters;
                const marginText = isNaN(marginMeters) ? 'N/A' : (
                    marginMeters > 0 ? 
                    `${marginMeters.toFixed(1)} m (ç¢ºä¿)` : 
                    `${Math.abs(marginMeters).toFixed(1)} m (å¹²æ¸‰/é®è”½)`
                );

                const txAngleText = propResults.txAngle !== undefined ? `${propResults.txAngle.toFixed(3)} Â°` : 'N/A';
                const rxAngleText = propResults.rxAngle !== undefined ? `${propResults.rxAngle.toFixed(3)} Â°` : 'N/A';
                
                // ä»°ä¿¯è§’ã®æ–¹å‘è¡¨ç¤º
                const txDir = propResults.txAngle > 0 ? 'ä»°è§’' : (propResults.txAngle < 0 ? 'ä¿¯è§’' : 'æ°´å¹³');
                const rxDir = propResults.rxAngle > 0 ? 'ä»°è§’' : (propResults.rxAngle < 0 ? 'ä¿¯è§’' : 'æ°´å¹³');


                propHtml = `
                    <h4>ã‚¢ãƒ³ãƒ†ãƒŠèª¿æ•´è§’åº¦ (K=${getCurrentKFactor().toFixed(3)})</h4>
                    <p>
                        <strong>Tx è¨­å®šä»°è§’:</strong> 
                        <span class="elevation-angle">${txAngleText} (${txDir})</span>
                    </p>
                    <p>
                        <strong>Rx è¨­å®šä»°è§’:</strong> 
                        <span class="elevation-angle">${rxAngleText} (${rxDir})</span>
                    </p>
                    <hr>
                    <h4>ä¼æ¬è¨ˆç®—çµæœ</h4>
                    <p><strong>é©ç”¨ãƒ¢ãƒ‡ãƒ«:</strong> <strong style="color: ${propResults.ad_loss > 0 ? 'darkorange' : 'green'};">${propResults.lossType}</strong></p>
                    <p><strong>â‘  å¹¾ä½•å­¦çš„LOS (ç›®è¦–):</strong> <span class="${losClass}">${losText}</span></p>
                    <p><strong>â‘¡ æœ€å°F1ãƒãƒ¼ã‚¸ãƒ³ (ä¼æ¬):</strong> ${marginText}</p>
                    <hr style="margin: 5px 0;">
                    <p><strong>è¿½åŠ æå¤± (Ad / Two-Ray):</strong> ${propResults.ad_loss.toFixed(2)} dB</p>
                    <p><strong>å…¨ä¼æ¬æå¤± (dB):</strong> ${propResults.totalLossDb.toFixed(2)} dB</p>
                    <p><strong>å—ä¿¡é›»åŠ› (dBm):</strong> <strong style="color: ${propResults.rxPowerDbm > -80 ? 'green' : 'red'};">${propResults.rxPowerDbm.toFixed(2)} dBm</strong></p>
                `;
            }

            const htmlContent = `
                <h4>è¨ˆæ¸¬ãƒ»åº§æ¨™æƒ…å ±</h4>
                <p><strong>2ç‚¹é–“è·é›¢:</strong> <strong style="color: blue;">${(dist / 1000).toFixed(3)} km</strong></p>
                <p><strong>æœ€é«˜æ¨™é«˜:</strong> <strong style="color: orange;">${maxPoint ? maxPoint.elevation.toFixed(1) + ' m' : 'N/A'}</strong></p>
                <hr>

                <table class="coord-table">
                    <thead>
                        <tr>
                            <th>é …ç›®</th>
                            <th>é€ä¿¡ç‚¹ (Tx)</th>
                            <th>å—ä¿¡ç‚¹ (Rx)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>ç·¯åº¦/çµŒåº¦ (WGS84)</th>
                            <td>${coord1[1].toFixed(5)}, ${coord1[0].toFixed(5)}</td>
                            <td>${coord2[1].toFixed(5)}, ${coord2[0].toFixed(5)}</td>
                        </tr>
                        <tr>
                            <th>MGRS (è»äº‹ã‚°ãƒªãƒƒãƒ‰)</th>
                            <td>${txMgrs}</td>
                            <td>${rxMgrs}</td>
                        </tr>
                        <tr>
                            <th>UTM (ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«æ¨ªãƒ¡ãƒ«ã‚«ãƒˆãƒ«)</th>
                            <td>${txUtm}</td>
                            <td>${rxUtm}</td>
                        </tr>
                        <tr>
                            <th>åœ°è¡¨é¢æ¨™é«˜ (m)</th>
                            <td>${elev1 !== null ? elev1.toFixed(1) + ' m' : 'N/A'}</td>
                            <td>${elev2 !== null ? elev2.toFixed(1) + ' m' : 'N/A'}</td>
                        </tr>
                        <tr>
                            <th>ç©ºä¸­ç·šé«˜ (m)</th>
                            <td>${txHeight.toFixed(1)} m</td>
                            <td>${rxHeight.toFixed(1)} m</td>
                        </tr>
                        <tr>
                            <th>çµ¶å¯¾é«˜ (m)</th>
                            <td>${elev1 !== null ? (elev1 + txHeight).toFixed(1) + ' m' : 'N/A'}</td>
                            <td>${elev2 !== null ? (elev2 + rxHeight).toFixed(1) + ' m' : 'N/A'}</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                ${propHtml}
            `;
            content.innerHTML = htmlContent;
        }

        // --- ãƒ¡ã‚¤ãƒ³ã®å‡¦ç†ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ© (å¤‰æ›´ãªã—) ---

        async function processMeasurement() {
            if (!points || points.length < 2) return;
            
            container.style.display = 'block'; 
            profileContainer.style.display = 'flex'; 
            
            profileStatus.classList.add('progress');
            profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
            const [coord1, coord2] = points; 
            
            vectorSource.getFeatures().forEach(feature => {
                if (feature.getGeometry().getType() === 'LineString') {
                    vectorSource.removeFeature(feature);
                }
            });

            const lineFeature = new ol.Feature({ geometry: new ol.geom.LineString([ol.proj.fromLonLat(coord1), ol.proj.fromLonLat(coord2)]) });
            vectorSource.addFeature(lineFeature);
            
            const profile = await getElevationProfile(coord1, coord2, DEFAULT_PROFILE_STEPS);
            
            if (!profile || profile.length < 2) {
                profileStatus.classList.remove('progress');
                profileStatus.textContent = 'ã‚¨ãƒ©ãƒ¼: æ¨™é«˜ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                alert('æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚');
                window.lastProfile = null;
                return;
            }
            
            vectorSource.getFeatures().forEach(feature => {
                if (feature.get('type') === 'max_elevation') {
                    vectorSource.removeFeature(feature);
                }
            });

            const maxElevationPoint = findMaxElevationPoint(profile);
            if (maxElevationPoint) {
                const maxElevFeature = new ol.Feature({ geometry: new ol.geom.Point(maxElevationPoint.webMercatorCoord), type: 'max_elevation' });
                vectorSource.addFeature(maxElevFeature);
            }
            
            const distanceMeters = ol.sphere.getDistance(coord1, coord2);

            // è¨ˆæ¸¬å®Œäº†æ™‚ã¯ã€ä»°è§’è¨ˆç®—ã¯ã¾ã å®Ÿè¡Œã—ãªã„ãŸã‚ null ã‚’æ¸¡ã™
            displayMeasurementResults(coord1, coord2, distanceMeters, profile[0].elevation, profile[profile.length - 1].elevation, maxElevationPoint, null);
            drawElevationChart(profile, distanceMeters);
            
            if (powerChart) { powerChart.destroy(); powerChart = null; }

            
            profileStatus.classList.remove('progress');
            profileStatus.textContent = `è¨ˆæ¸¬å®Œäº†ã€‚å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} kmã€‚ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚`;

            window.lastProfile = profile;
            window.lastDistance = distanceMeters;
            window.lastMaxElevation = maxElevationPoint;
        }

        function executeRecalculation() {
            if (!window.lastProfile || !window.lastDistance) {
                alert('å…ˆã«åœ°å›³ä¸Šã§2ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            const K_FACTOR = getCurrentKFactor();
            profileStatus.classList.add('progress');
            profileStatus.textContent = `K=${K_FACTOR.toFixed(3)} ã®æ¡ä»¶ã§ä¼æ¬è¨ˆç®—ã¨ä»°ä¿¯è§’è¨ˆç®—ã‚’å®Ÿè¡Œä¸­...`;
            
            const [coord1, coord2] = points;

            // ã“ã“ã§ä»°ä¿¯è§’ã‚’å«ã‚€ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œ
            const propResults = calculatePropagation(window.lastProfile, window.lastDistance);
            
            if (propResults.error) {
                alert(`ä¼æ¬è¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${propResults.error}`);
                profileStatus.classList.remove('progress');
                profileStatus.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                return;
            }
            
            displayMeasurementResults(
                coord1, coord2, window.lastDistance, 
                window.lastProfile[0].elevation, 
                window.lastProfile[window.lastProfile.length - 1].elevation, 
                window.lastMaxElevation, 
                propResults // ä»°ä¿¯è§’ã‚’å«ã‚€çµæœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¸¡ã™
            );
            
            drawElevationChart(window.lastProfile, window.lastDistance); 
            drawPowerChart(propResults); 
            
            profileStatus.classList.remove('progress');
            profileStatus.textContent = `${propResults.lossType.split('(')[0].trim()}è¨ˆç®—å®Œäº†ã€‚å—ä¿¡é›»åŠ›: ${propResults.rxPowerDbm.toFixed(2)} dBm (K=${K_FACTOR.toFixed(3)})ã€‚Txä»°è§’: ${propResults.txAngle.toFixed(3)} Â°`;
        }

        // å†è¨ˆç®—ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('simple-recalculate-btn').addEventListener('click', executeRecalculation);

        // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (å¤‰æ›´ãªã—)
        document.querySelectorAll('.preset-btn').forEach(button => {
            button.addEventListener('click', (event) => {
                const scenario = event.currentTarget.getAttribute('data-scenario');
                applyPreset(scenario);
            });
        });

        // --- ãƒ‰ãƒ©ãƒƒã‚°/ãƒªã‚µã‚¤ã‚ºæ©Ÿèƒ½ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š (å¤‰æ›´ãªã—) ---
        popupHeader.addEventListener('mousedown', event => startDrag(event, container));
        popupHeader.addEventListener('touchstart', event => startDrag(event, container), { passive: false });
        profileHeader.addEventListener('mousedown', event => startDrag(event, profileContainer));
        profileHeader.addEventListener('touchstart', event => startDrag(event, profileContainer), { passive: false });

        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', stopDrag);

        // ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³ (å¤‰æ›´ãªã—)
        closer.onclick = function() { resetMeasurement(); return false; };
        profileCloser.onclick = function() {
            profileContainer.style.display = 'none';
            return false;
        };

        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´æ™‚ (Kãƒ•ã‚¡ã‚¯ã‚¿ãƒ¼ã®å¤‰æ›´ã‚‚å«ã‚€) ã®å‡¦ç†
        document.querySelectorAll('#propagation-controls input').forEach(input => {
            input.addEventListener('change', (event) => {
                if (window.lastProfile) {
                    profileStatus.textContent = 'ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚ã€Œä¼æ¬è¨ˆç®—å®Ÿè¡Œã€ã‚’æŠ¼ã—ã¦æ›´æ–°ã—ã¦ãã ã•ã„ã€‚';
                    
                    if (event.target.name === 'k_factor') {
                        drawElevationChart(window.lastProfile, window.lastDistance);
                    }
                    
                    if (points.length === 2) {
                        const [coord1, coord2] = points;
                         displayMeasurementResults(
                            coord1, coord2, window.lastDistance, 
                            window.lastProfile[0].elevation, 
                            window.lastProfile[window.lastProfile.length - 1].elevation, 
                            window.lastMaxElevation, 
                            null
                        );
                    }
                }
            });
        });

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ™ãƒ³ãƒˆã¨ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹ç„¡åŠ¹åŒ–ãƒ­ã‚¸ãƒƒã‚¯ã®çµ±åˆ (å¤‰æ›´ãªã—)
        function handleBaseMapChange() {
            const baseType = document.querySelector('input[name="base_type"]:checked').value;
            const tileSourceOptionsDiv = document.getElementById('tile-source-options');
            const tileSourceInputs = tileSourceOptionsDiv.querySelectorAll('input[name="tile_source"]');
            
            const shouldDisable = (baseType === 'photo');
            tileSourceInputs.forEach(input => {
                input.disabled = shouldDisable;
            });

            tileSourceOptionsDiv.style.opacity = shouldDisable ? '0.5' : '1.0';

            const tileSource = document.querySelector('input[name="tile_source"]:checked').value;
            baseLayerGroup.getLayers().forEach(layer => layer.setVisible(false));
            
            if (baseType === 'std') {
                if (tileSource === 'osm') osmLayer.setVisible(true);
                else if (tileSource === 'gsi') gsiStdLayer.setVisible(true);
            } else if (baseType === 'photo') {
                gsiPhotoLayer.setVisible(true);
            }
        }
        
        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') {
                handleBaseMapChange();
            }
        });

        map.on('click', async (evt) => {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);
            if (points.length >= 2) resetMeasurement();
            addPointFeature(webMercatorCoord);
            points.push(lonLatCoord);
            
            if (points.length === 2) {
                await processMeasurement();
            } else {
                profileContainer.style.display = 'none'; 
                container.style.display = 'block'; 
                content.innerHTML = `<h4>è¨ˆæ¸¬ãƒ»åº§æ¨™æƒ…å ±</h4><p>1ç‚¹ç›®åº§æ¨™: ${lonLatCoord[1].toFixed(5)}, ${lonLatCoord[0].toFixed(5)}</p><p>2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>`;
            }
        });

        // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã®çŠ¶æ…‹è¨­å®š (å¤‰æ›´ãªã—)
        window.onload = () => {
            resetMeasurement(); 
            handleBaseMapChange();
        };

    </script>
</body>
</html>
