<!DOCTYPE html>
<html lang="ja">
<head>
    <title>OpenLayers çµ±åˆè¨ˆæ¸¬ãƒ»ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å€‹åˆ¥ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œ</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css" integrity="sha384-..." crossorigin="anonymous">
    <style>
        #map {
            width: 100%;
            height: 900px;
        }
        /* è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .ol-popup {
            position: absolute;
            background-color: white;
            padding: 0;
            border-radius: 5px;
            border: 1px solid #cccccc;
            bottom: 12px;
            left: -50px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-width: 200px;
            z-index: 100;
        }
        #popup-header {
            cursor: move;
            background-color: #f0f0f0;
            padding: 5px 15px;
            border-bottom: 1px solid #ccc;
            font-weight: bold;
        }
        #popup-content {
            padding: 15px;
        }
        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 5px;
            right: 8px;
            z-index: 10;
        }
        .ol-popup-closer:after {
            content: "âœ–";
        }
        /* æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #profile-popup {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #1f77b4;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 300px;
            min-height: 150px;
            max-height: 80vh;
            position: absolute;
            z-index: 99;
            box-sizing: border-box;
            resize: both;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        #profile-popup-header {
            font-weight: bold;
            margin-bottom: 5px;
            cursor: move;
            background-color: #e6f2ff;
            padding: 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #profile-closer {
            position: absolute;
            top: 5px;
            right: 8px;
            text-decoration: none;
            font-weight: bold;
            color: #333;
        }
        #profile-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }
        #elevationChart {
            width: 100% !important;
            flex-grow: 1;
            min-height: 100px;
        }
        #profile-status {
            flex-shrink: 0;
            padding-top: 5px;
            font-size: 0.9em;
        }
        #profile-status.progress::before {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
            margin-right: 5px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #layer-switcher {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1000;
        }
        #layer-switcher label input:checked + span {
            background-color: #e6f2ff;
            font-weight: bold;
            display: inline-block;
            padding: 2px 5px;
            border-radius: 3px;
        }
        /* ğŸŒŸ ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«æœ€å‰é¢ã«ã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ */
        .ol-popup.top-zindex {
            z-index: 101 !important;
        }
        #profile-popup.top-zindex {
            z-index: 101 !important;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="profile-popup" role="dialog" aria-label="æ¨™é«˜æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="profile-popup-header" tabindex="0" aria-label="æ¨™é«˜æ–­é¢å›³ãƒ˜ãƒƒãƒ€ãƒ¼">æ¨™é«˜æ–­é¢å›³</div>
        <a href="#" id="profile-closer" aria-label="æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0">âœ–</a>
        <div id="profile-content">
            <canvas id="elevationChart" aria-label="æ¨™é«˜æ–­é¢å›³"></canvas>
            <div id="profile-status" aria-live="polite">2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...</div>
        </div>
    </div>

    <div id="popup" class="ol-popup" role="dialog" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="popup-header" tabindex="0" aria-label="è¨ˆæ¸¬çµæœãƒ˜ãƒƒãƒ€ãƒ¼">è¨ˆæ¸¬çµæœ</div>
        <a href="#" id="popup-closer" class="ol-popup-closer" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0"></a>
        <div id="popup-content" aria-live="polite"></div>
    </div>

    <div id="layer-switcher">
        <div>ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="base_type" value="std" checked><span> æ¨™æº–ï¼ˆåœ°å›³ï¼‰</span></label><br>
        <label><input type="radio" name="base_type" value="photo"><span> å†™çœŸï¼ˆåœ°ç†é™¢ï¼‰</span></label><hr>
        <div>ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="tile_source" value="osm" checked><span> OpenStreetMap</span></label><br>
        <label><input type="radio" name="tile_source" value="gsi"><span> å›½åœŸåœ°ç†é™¢ï¼ˆæ¨™æº–ï¼‰</span></label>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js" integrity="sha384-..." crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" integrity="sha384-..." crossorigin="anonymous"></script>

    <script>
        // å®šæ•°å®šç¾©
        const ELEVATION_API_URL = 'https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php';
        const DEFAULT_PROFILE_STEPS = 30;
        const MAX_PROFILE_STEPS = 100;
        const API_TIMEOUT_MS = 5000;

        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const elevationCache = new Map();

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾©
        const osmLayer = new ol.layer.Tile({
            title: 'OpenStreetMap',
            type: 'base',
            visible: true,
            source: new ol.source.OSM()
        });
        const gsiStdLayer = new ol.layer.Tile({
            title: 'GSI_Standard',
            type: 'base',
            visible: false,
            source: new ol.source.XYZ({
                url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png',
                attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>'
            })
        });
        const gsiPhotoLayer = new ol.layer.Tile({
            title: 'GSI_Photo',
            type: 'base',
            visible: false,
            source: new ol.source.XYZ({
                url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg',
                attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>'
            })
        });
        const baseLayerGroup = new ol.layer.Group({ layers: [osmLayer, gsiStdLayer, gsiPhotoLayer] });

        // 2ç‚¹é–“è¨ˆæ¸¬ç”¨å¤‰æ•°ã¨ãƒãƒ¼ã‚«ãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼
        let points = [];
        const vectorSource = new ol.source.Vector();
        const lineStyle = new ol.style.Style({
            stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 255, 0.7)', width: 4, lineDash: [10, 5] })
        });
        const maxElevStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 10,
                fill: new ol.style.Fill({ color: 'orange' }),
                stroke: new ol.style.Stroke({ color: 'black', width: 3 })
            })
        });
        const pointStyle = new ol.style.Style({
            image: new ol.style.Circle({
                radius: 7,
                fill: new ol.style.Fill({ color: 'red' }),
                stroke: new ol.style.Stroke({ color: 'white', width: 2 })
            })
        });

        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.get('type') === 'max_elevation') return maxElevStyle;
                if (feature.getGeometry().getType() === 'LineString') return lineStyle;
                return pointStyle;
            }
        });

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®è¨­å®š
        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');
        const popupHeader = document.getElementById('popup-header');
        const overlay = new ol.Overlay({ element: container, autoPan: true, autoPanAnimation: { duration: 250 } });

        // æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®è¨­å®š
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');
        const profileHeader = document.getElementById('profile-popup-header');
        const profileOverlay = new ol.Overlay({ element: profileContainer, autoPan: false, positioning: 'bottom-center' });
        profileOverlay.setPosition(undefined);

        // åœ°å›³ã®åˆæœŸåŒ–
        const map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, vectorLayer],
            overlays: [overlay, profileOverlay],
            view: new ol.View({
                center: ol.proj.fromLonLat([139.75, 35.68]),
                zoom: 12,
                maxZoom: 18
            })
        });

        // Chart.jsã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let elevationChart = null;

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½
        let isDragging = false;
        let startPixel;
        let startCoord;
        let currentDraggingOverlay = null;

        function startDrag(event, targetOverlay) {
            const isTouchEvent = event.type.includes('touch');
            if (isTouchEvent || event.button === 0) {
                event.preventDefault();
            }
            const style = window.getComputedStyle(profileContainer);
            if (style.cursor.includes('resize')) return;

            if (targetOverlay.getPosition()) {
                isDragging = true;
                const eventPoint = isTouchEvent ? [event.touches[0].clientX, event.touches[0].clientY] : [event.clientX, event.clientY];
                startPixel = map.getEventPixel(eventPoint);
                startCoord = targetOverlay.getPosition();
                currentDraggingOverlay = targetOverlay;
                targetOverlay.getElement().classList.add('top-zindex');
                if (targetOverlay === overlay) profileContainer.classList.remove('top-zindex');
                if (targetOverlay === profileOverlay) container.classList.remove('top-zindex');
                map.getInteractions().forEach(interaction => interaction.setActive(false));
            }
        }

        function handleDragMove(event) {
            if (!isDragging || !currentDraggingOverlay) return;
            const isTouchEvent = event.type.includes('touch');
            if (isTouchEvent) event.preventDefault();
            const currentPixel = isTouchEvent ? map.getEventPixel([event.touches[0].clientX, event.touches[0].clientY]) : map.getEventPixel(event);
            const deltaPixelX = currentPixel[0] - startPixel[0];
            const deltaPixelY = currentPixel[1] - startPixel[1];
            const newCoordPixel = map.getPixelFromCoordinate(startCoord);
            const newCoord = map.getCoordinateFromPixel([newCoordPixel[0] + deltaPixelX, newCoordPixel[1] + deltaPixelY]);
            try {
                currentDraggingOverlay.setPosition(newCoord);
            } catch (error) {
                console.error('ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ç§»å‹•ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
            }
        }

        function stopDrag() {
            if (isDragging) {
                if (currentDraggingOverlay) {
                    currentDraggingOverlay.getElement().classList.remove('top-zindex');
                }
                isDragging = false;
                currentDraggingOverlay = null;
                map.getInteractions().forEach(interaction => interaction.setActive(true));
            }
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        popupHeader.addEventListener('mousedown', event => startDrag(event, overlay));
        profileHeader.addEventListener('mousedown', event => startDrag(event, profileOverlay));
        document.addEventListener('mousemove', handleDragMove, { passive: false });
        document.addEventListener('mouseup', stopDrag);
        popupHeader.addEventListener('touchstart', event => startDrag(event, overlay), { passive: false });
        profileHeader.addEventListener('touchstart', event => startDrag(event, profileOverlay), { passive: false });
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', stopDrag);

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
        popupHeader.addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                overlay.setPosition(undefined);
                closer.blur();
                resetMeasurement();
            }
        });
        profileHeader.addEventListener('keydown', event => {
            if (event.key === 'Enter') {
                profileOverlay.setPosition(undefined);
            }
        });

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—é–‰ã˜ã‚‹å‡¦ç†
        closer.onclick = function() {
            resetMeasurement();
            return false;
        };
        profileCloser.onclick = function() {
            profileOverlay.setPosition(undefined);
            return false;
        };

        function resetMeasurement() {
            overlay.setPosition(undefined);
            vectorSource.clear();
            points = [];
            if (elevationChart) elevationChart.destroy();
            elevationChart = null;
            profileOverlay.setPosition(undefined);
            profileStatus.textContent = '2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...';
        }

        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹é–¢æ•°
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => func.apply(this, args), delay);
            };
        }

        // ãƒªã‚µã‚¤ã‚ºæ™‚ã®Chart.jså†æç”»
        const debouncedChartResize = debounce(() => {
            if (elevationChart) elevationChart.resize();
        }, 50);
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target.id === 'profile-popup') debouncedChartResize();
            }
        });
        resizeObserver.observe(profileContainer);

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ä½ç½®èª¿æ•´
        function adjustOverlayPosition(overlay, coord) {
            const pixel = map.getPixelFromCoordinate(coord);
            const mapSize = map.getSize();
            const overlayElement = overlay.getElement();
            const overlayWidth = overlayElement.offsetWidth;
            const overlayHeight = overlayElement.offsetHeight;

            pixel[0] = Math.max(overlayWidth / 2, Math.min(pixel[0], mapSize[0] - overlayWidth / 2));
            pixel[1] = Math.max(overlayHeight, Math.min(pixel[1], mapSize[1] - overlayHeight / 2));

            const adjustedCoord = map.getCoordinateFromPixel(pixel);
            overlay.setPosition(adjustedCoord);
        }

        // ã‚¿ã‚¤ãƒ«åˆ‡ã‚Šæ›¿ãˆ
        function hideAllBaseLayers() {
            baseLayerGroup.getLayers().forEach(layer => layer.setVisible(false));
        }
        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') {
                const baseType = document.querySelector('input[name="base_type"]:checked').value;
                const tileSource = document.querySelector('input[name="tile_source"]:checked').value;
                hideAllBaseLayers();
                if (baseType === 'std') {
                    if (tileSource === 'osm') osmLayer.setVisible(true);
                    else if (tileSource === 'gsi') gsiStdLayer.setVisible(true);
                } else if (baseType === 'photo') gsiPhotoLayer.setVisible(true);
            }
        });

        // æ¨™é«˜æ–­é¢å›³æç”»
        function drawElevationChart(profile, distanceMeters) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            const labels = profile.map((_, index) => {
                const fraction = index / (profile.length - 1);
                const dist = distanceMeters * fraction;
                return (dist / 1000).toFixed(2);
            });
            const elevations = profile.map(p => p.elevation);

            if (elevationChart) {
                elevationChart.data.labels = labels;
                elevationChart.data.datasets[0].data = elevations;
                elevationChart.options.scales.x.title.text = `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km`;
                elevationChart.update();
            } else {
                elevationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'æ¨™é«˜ (m)',
                            data: elevations,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { title: { display: true, text: `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km` } },
                            y: { title: { display: true, text: 'æ¨™é«˜ (m)' }, beginAtZero: false }
                        },
                        plugins: { legend: { display: false }, title: { display: false } }
                    }
                });
            }
            profileStatus.textContent = `è¨ˆæ¸¬å®Œäº†ã€‚å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km`;
        }

        // æ¨™é«˜å–å¾—
        async function getElevation(coordinate) {
            const key = `${coordinate[0]},${coordinate[1]}`;
            if (elevationCache.has(key)) {
                return elevationCache.get(key);
            }
            const [lon, lat] = coordinate;
            const url = `${ELEVATION_API_URL}?lat=${lat}&lon=${lon}&outtype=json`;
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
                const response = await fetch(url, { signal: controller.signal });
                clearTimeout(timeoutId);
                const data = await response.json();
                if (data.elevation === 'å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ') {
                    profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
                    return null;
                }
                const elevation = parseFloat(data.elevation);
                elevationCache.set(key, elevation);
                return elevation;
            } catch (error) {
                console.error(`æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: åº§æ¨™ [${lon}, ${lat}]`, error);
                profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
                return null;
            }
        }

        // ç·šå½¢è£œé–“
        function interpolateCoordinates(coordA, coordB, fraction) {
            const lon = coordA[0] + (coordB[0] - coordA[0]) * fraction;
            const lat = coordA[1] + (coordB[1] - coordA[1]) * fraction;
            return [lon, lat];
        }

        // æ¨™é«˜ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—
        async function getElevationProfile(coord1, coord2, maxSteps = DEFAULT_PROFILE_STEPS) {
            const distanceMeters = ol.sphere.getDistance(coord1, coord2);
            const steps = Math.min(maxSteps, Math.ceil(distanceMeters / 1000));
            const profile = [];
            for (let i = 0; i <= steps; i++) {
                const fraction = i / steps;
                const intermediateCoord = interpolateCoordinates(coord1, coord2, fraction);
                const elevation = await getElevation(intermediateCoord);
                profile.push({
                    coord: intermediateCoord,
                    webMercatorCoord: ol.proj.fromLonLat(intermediateCoord),
                    elevation: elevation
                });
            }
            return profile;
        }

        // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
        async function handleMapClick(evt) {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);

            overlay.setPosition(undefined);
            resetMeasurementIfComplete();

            addPointFeature(webMercatorCoord);
            points.push(lonLatCoord);

            if (points.length === 2) {
                await processMeasurement();
            } else {
                profileStatus.textContent = '2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’å®Œäº†ã—ã¦ãã ã•ã„ã€‚';
            }
        }

        function resetMeasurementIfComplete() {
            if (points.length >= 2) resetMeasurement();
        }

        function addPointFeature(webMercatorCoord) {
            const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord) });
            vectorSource.addFeature(pointFeature);
        }

        async function processMeasurement() {
            profileStatus.classList.add('progress');
            profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
            const [coord1, coord2] = points;

            const lineFeature = new ol.Feature({
                geometry: new ol.geom.LineString([ol.proj.fromLonLat(coord1), ol.proj.fromLonLat(coord2)])
            });
            vectorSource.addFeature(lineFeature);

            const profile = await getElevationProfile(coord1, coord2, DEFAULT_PROFILE_STEPS);
            const maxElevationPoint = findMaxElevationPoint(profile);
            if (maxElevationPoint) {
                const maxElevFeature = new ol.Feature({
                    geometry: new ol.geom.Point(maxElevationPoint.webMercatorCoord),
                    type: 'max_elevation'
                });
                vectorSource.addFeature(maxElevFeature);
            }

            const distanceMeters = ol.sphere.getDistance(coord1, coord2);
            displayMeasurementResults(profile, distanceMeters, maxElevationPoint);
            drawElevationChart(profile, distanceMeters);

            const centerCoord = calculateCenterCoord();
            adjustOverlayPosition(overlay, centerCoord);
            adjustOverlayPosition(profileOverlay, centerCoord);

            profileStatus.classList.remove('progress');
        }

        function findMaxElevationPoint(profile) {
            let maxElevation = -Infinity;
            let maxElevationPoint = null;
            profile.forEach(p => {
                if (p.elevation !== null && p.elevation > maxElevation) {
                    maxElevation = p.elevation;
                    maxElevationPoint = p;
                }
            });
            return maxElevationPoint;
        }

        function displayMeasurementResults(profile, distanceMeters, maxElevationPoint) {
            const htmlContent = `
                <p><strong>å§‹ç‚¹:</strong> æ¨™é«˜: ${profile[0].elevation !== null ? profile[0].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                <p><strong>çµ‚ç‚¹:</strong> æ¨™é«˜: ${profile[profile.length - 1].elevation !== null ? profile[profile.length - 1].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                <p><strong>æœ€é«˜æ¨™é«˜:</strong> <strong style="color: orange;">${maxElevationPoint ? maxElevationPoint.elevation.toFixed(1) + ' m' : 'N/A'}</strong></p>
                <hr>
                <p><strong>2ç‚¹é–“è·é›¢:</strong> <strong style="color: blue;">${(distanceMeters / 1000).toFixed(3)} km (${distanceMeters.toFixed(0)} m)</strong></p>
            `;
            content.innerHTML = htmlContent;
        }

        function calculateCenterCoord() {
            const features = vectorSource.getFeatures();
            return [
                (features[0].getGeometry().getCoordinates()[0] + features[1].getGeometry().getCoordinates()[0]) / 2,
                (features[0].getGeometry().getCoordinates()[1] + features[1].getGeometry().getCoordinates()[1]) / 2
            ];
        }

        map.on('click', handleMapClick);
    </script>
</body>
</html>
