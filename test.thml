<!DOCTYPE html>
<html>
<head>
    <title>OpenLayers 統合計測・ポップアップ個別ドラッグ対応</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
    <style>
        #map {
            width: 100%;
            height: 900px;
        }
        /* 計測結果ポップアップのスタイル */
        .ol-popup {
            position: absolute; background-color: white; padding: 0; border-radius: 5px;
            border: 1px solid #cccccc; bottom: 12px; left: -50px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-width: 200px; z-index: 100;
        }
        #popup-header {
            cursor: move; background-color: #f0f0f0; padding: 5px 15px; border-bottom: 1px solid #ccc;
            font-weight: bold;
        }
        #popup-content { padding: 15px; }
        .ol-popup-closer { text-decoration: none; position: absolute; top: 5px; right: 8px; z-index: 10; }
        .ol-popup-closer:after { content: "✖"; }

        /* 断面図ポップアップのスタイル */
        #profile-popup {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #1f77b4;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 400px;
            min-height: 200px;
            position: absolute;
            z-index: 99;

            box-sizing: border-box;
            resize: both;
            overflow: auto;
            max-height: 80vh;

            display: flex;
            flex-direction: column;
        }
        #profile-popup-header {
            font-weight: bold;
            margin-bottom: 5px;
            cursor: move;
            background-color: #e6f2ff;
            padding: 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #profile-closer {
            position: absolute;
            top: 5px;
            right: 8px;
            text-decoration: none;
            font-weight: bold;
            color: #333;
        }

        #profile-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }

        /* Chart.js のコンテナスタイル */
        #elevationChart {
            width: 100% !important;
            flex-grow: 1;
            min-height: 100px;
        }
        #profile-status {
            flex-shrink: 0;
            padding-top: 5px;
        }

        /* レイヤー切り替えボタンコンテナのスタイル */
        #layer-switcher {
            position: absolute; top: 10px; left: 10px; background: white; padding: 10px;
            border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="profile-popup">
        <div id="profile-popup-header">標高断面図</div>
        <a href="#" id="profile-closer">✖</a>
        <div id="profile-content">
            <canvas id="elevationChart"></canvas>
            <div id="profile-status" style="font-size: 0.9em; margin-top: 5px;"></div>
        </div>
    </div>

    <div id="popup" class="ol-popup">
        <div id="popup-header">計測結果</div>
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>

    <div id="layer-switcher">
        <div>ベースマップ切り替え</div>
        <label><input type="radio" name="base_type" value="std" checked> 標準（地図）</label><br>
        <label><input type="radio" name="base_type" value="photo"> 写真（地理院）</label><hr>
        <div>タイルソース切り替え</div>
        <label><input type="radio" name="tile_source" value="osm" checked> OpenStreetMap</label><br>
        <label><input type="radio" name="tile_source" value="gsi"> 国土地理院（標準）</label>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // --- 1. レイヤー定義 ---
        const osmLayer = new ol.layer.Tile({ title: 'OpenStreetMap', type: 'base', visible: true, source: new ol.source.OSM() });
        const gsiStdLayer = new ol.layer.Tile({ title: 'GSI_Standard', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>' }) });
        const gsiPhotoLayer = new ol.layer.Tile({ title: 'GSI_Photo', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">地理院タイル</a>' }) });
        const baseLayerGroup = new ol.layer.Group({ layers: [osmLayer, gsiStdLayer, gsiPhotoLayer] });

        // --- 2. 2点間計測用変数とマーカーレイヤー ---
        let points = [];
        const vectorSource = new ol.source.Vector();
        const lineStyle = new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 255, 0.7)', width: 4, lineDash: [10, 5] }) });
        const maxElevStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({color: 'orange'}), stroke: new ol.style.Stroke({color: 'black', width: 3}) }) });
        const pointStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({color: 'red'}), stroke: new ol.style.Stroke({color: 'white', width: 2}) }) });

        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.get('type') === 'max_elevation') { return maxElevStyle; }
                else if (feature.getGeometry().getType() === 'LineString') { return lineStyle; }
                else { return pointStyle; }
            }
        });

        // ポップアップの設定
        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');
        const popupHeader = document.getElementById('popup-header');
        const overlay = new ol.Overlay({ element: container, autoPan: true, autoPanAnimation: { duration: 250 } });

        // 断面図ポップアップの設定
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');
        const profileHeader = document.getElementById('profile-popup-header');

        const profileOverlay = new ol.Overlay({
            element: profileContainer,
            autoPan: false,
            positioning: 'bottom-center'
        });
        profileOverlay.setPosition(undefined);

        closer.onclick = function() {
            overlay.setPosition(undefined); closer.blur(); vectorSource.clear(); points = [];
            if (elevationChart) elevationChart.destroy();
            profileOverlay.setPosition(undefined);
            return false;
        };
        profileCloser.onclick = function() {
            profileOverlay.setPosition(undefined);
            return false;
        };


        // --- 3. ポップアップのドラッグ機能とリサイズ安定化 (修正済み) ---
        let isDragging = false;
        let startPixel;
        let startCoord;
        let currentDraggingOverlay = null; // 🌟 現在ドラッグ中のオーバーレイを追跡

        // 共通のドラッグ開始処理
        function startDrag(event, targetOverlay) {
            // リサイズ操作中はドラッグを無効化する
            const style = window.getComputedStyle(profileContainer);
            if (style.cursor === 'nwse-resize' || style.cursor === 'se-resize') {
                 return;
            }

            if (targetOverlay.getPosition()) {
                isDragging = true;
                startPixel = map.getEventPixel(event);
                startCoord = targetOverlay.getPosition();
                currentDraggingOverlay = targetOverlay; // 🌟 ドラッグ対象を記録
                map.getInteractions().forEach(function(interaction) { interaction.setActive(false); });
            }
        }

        // 計測結果ポップアップのドラッグ
        popupHeader.addEventListener('mousedown', function(event) {
            startDrag(event, overlay);
        });

        // 断面図ポップアップのドラッグ
        profileHeader.addEventListener('mousedown', function(event) {
            startDrag(event, profileOverlay);
        });

        // 共通のドラッグ移動・終了処理
        document.addEventListener('mousemove', function(event) {
            if (!isDragging || !currentDraggingOverlay) return; // 🌟 ドラッグ対象がなければ抜ける

            const currentPixel = map.getEventPixel(event);
            const deltaPixelX = currentPixel[0] - startPixel[0];
            const deltaPixelY = currentPixel[1] - startPixel[1];

            const newCoordPixel = map.getPixelFromCoordinate(startCoord);
            const newCoord = map.getCoordinateFromPixel([ newCoordPixel[0] + deltaPixelX, newCoordPixel[1] + deltaPixelY ]);
            currentDraggingOverlay.setPosition(newCoord); // 🌟 記録されたオーバーレイを移動
        });
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                currentDraggingOverlay = null; // 🌟 ドラッグ終了時にリセット
                map.getInteractions().forEach(function(interaction) { interaction.setActive(true); });
            }
        });

        // デバウンス関数の定義 (安定化のため)
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // リサイズ後の Chart.js の再描画（デバウンス適用）
        const debouncedChartResize = debounce(() => {
            if (elevationChart) {
                elevationChart.resize();
            }
        }, 50);

        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target.id === 'profile-popup') {
                    debouncedChartResize();
                }
            }
        });
        resizeObserver.observe(profileContainer);


        // --- 4. 地図の初期化 ---
        const map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, vectorLayer],
            overlays: [overlay, profileOverlay],
            view: new ol.View({
                center: ol.proj.fromLonLat([139.75, 35.68]),
                zoom: 12,
                maxZoom: 18
            })
        });


        // --- 5. タイル切り替え機能 (省略) ---
        function hideAllBaseLayers() { baseLayerGroup.getLayers().forEach(layer => { layer.setVisible(false); }); }
        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') {
                const baseType = document.querySelector('input[name="base_type"]:checked').value;
                const tileSource = document.querySelector('input[name="tile_source"]:checked').value;
                hideAllBaseLayers();
                if (baseType === 'std') {
                    if (tileSource === 'osm') { osmLayer.setVisible(true); } else if (tileSource === 'gsi') { gsiStdLayer.setVisible(true); }
                } else if (baseType === 'photo') { gsiPhotoLayer.setVisible(true); }
            }
        });


        // --- 6. 標高断面図（Chart.js）関連関数 ---
        let elevationChart = null;

        function drawElevationChart(profile, distanceMeters) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            const labels = profile.map((_, index) => {
                const fraction = index / (profile.length - 1);
                const dist = distanceMeters * fraction;
                return (dist / 1000).toFixed(2);
            });
            const elevations = profile.map(p => p.elevation);

            if (elevationChart) { elevationChart.destroy(); }

            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: '標高 (m)',
                        data: elevations,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: `距離 (km) - 全長: ${(distanceMeters / 1000).toFixed(3)} km` } },
                        y: { title: { display: true, text: '標高 (m)' }, beginAtZero: false }
                    },
                    plugins: { legend: { display: false }, title: { display: false } }
                }
            });
            profileStatus.textContent = `計測完了。全長: ${(distanceMeters / 1000).toFixed(3)} km`;
        }

        // 標高取得関数 (省略)
        async function getElevation(coordinate) {
            const [lon, lat] = coordinate;
            const url = `https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php?lat=${lat}&lon=${lon}&outtype=json`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.elevation !== '取得できませんでした' ? parseFloat(data.elevation) : null;
            } catch (error) {
                console.error("標高データの取得中にエラーが発生しました:", error);
                return null;
            }
        }

        // 線形補間関数 (省略)
        function interpolateCoordinates(coordA, coordB, fraction) {
            const lon = coordA[0] + (coordB[0] - coordA[0]) * fraction;
            const lat = coordA[1] + (coordB[1] - coordA[1]) * fraction;
            return [lon, lat];
        }

        // 2点間の標高を複数地点で取得する関数 (省略)
        async function getElevationProfile(coord1, coord2, steps = 30) {
            const profile = [];
            for (let i = 0; i <= steps; i++) {
                const fraction = i / steps;
                const intermediateCoord = interpolateCoordinates(coord1, coord2, fraction);
                const elevation = await getElevation(intermediateCoord);

                profile.push({
                    coord: intermediateCoord,
                    webMercatorCoord: ol.proj.fromLonLat(intermediateCoord),
                    elevation: elevation
                });
            }
            return profile;
        }

        // --- 7. クリックイベント（2点間計測） ---
        map.on('click', async function(evt) {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);

            overlay.setPosition(undefined);

            if (points.length >= 2) {
                points = [];
                vectorSource.clear();
                profileOverlay.setPosition(undefined);
                profileStatus.textContent = '2点目を待っています...';
            }

            const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord) });
            vectorSource.addFeature(pointFeature);
            points.push(lonLatCoord);

            if (points.length === 2) {
                profileStatus.textContent = '標高データを取得中...';
                const [coord1, coord2] = points;

                // 線の追加
                const lineFeature = new ol.Feature({
                    geometry: new ol.geom.LineString([ ol.proj.fromLonLat(coord1), ol.proj.fromLonLat(coord2) ])
                });
                vectorSource.addFeature(lineFeature);

                // 標高プロファイルの取得と最高地点の特定
                const profile = await getElevationProfile(coord1, coord2, 30);
                let maxElevation = -Infinity;
                let maxElevationPoint = null;
                profile.forEach(p => { if (p.elevation !== null && p.elevation > maxElevation) { maxElevation = p.elevation; maxElevationPoint = p; } });

                // 最高地点のマーキング
                if (maxElevationPoint) {
                    const maxElevFeature = new ol.Feature({
                        geometry: new ol.geom.Point(maxElevationPoint.webMercatorCoord),
                        type: 'max_elevation'
                    });
                    vectorSource.addFeature(maxElevFeature);
                }

                // 距離の計算と計測結果ポップアップの表示
                const distanceMeters = ol.sphere.getDistance(coord1, coord2);
                const htmlContent = `
                    <p><strong>始点:</strong> 標高: ${profile[0].elevation !== null ? profile[0].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                    <p><strong>終点:</strong> 標高: ${profile[profile.length - 1].elevation !== null ? profile[profile.length - 1].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                    <p><strong>最高標高:</strong> <strong style="color: orange;">${maxElevationPoint ? maxElevationPoint.elevation.toFixed(1) + ' m' : 'N/A'}</strong></p>
                    <hr>
                    <p><strong>2点間距離:</strong> <strong style="color: blue;">${(distanceMeters / 1000).toFixed(3)} km (${distanceMeters.toFixed(0)} m)</strong></p>
                `;
                content.innerHTML = htmlContent;

                // ポップアップを2点間の中間位置に表示
                const features = vectorSource.getFeatures();
                const centerCoord = [
                    (features[0].getGeometry().getCoordinates()[0] + features[1].getGeometry().getCoordinates()[0]) / 2,
                    (features[0].getGeometry().getCoordinates()[1] + features[1].getGeometry().getCoordinates()[1]) / 2
                ];

                overlay.setPosition(centerCoord);

                // 断面図の描画と表示
                drawElevationChart(profile, distanceMeters);
                profileOverlay.setPosition(centerCoord);
            } else {
                 profileStatus.textContent = '2点目をクリックして計測を完了してください。';
            }
        });
    </script>
</body>
</html>
