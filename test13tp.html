<!DOCTYPE html>
<html lang="ja">
<head>
    <title>OpenLayers 統合計測・伝搬計算（UTM/MGRS対応版）</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css">

    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mgrs@2.1.0/dist/mgrs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        /* 必須：地図コンテナのサイズを定義 */
        body { margin: 0; padding: 0; overflow: hidden; }
        #map {
            width: 100%;
            height: 100vh;
        }

        /* --- コントロール/結果ウィンドウ共通スタイル --- */
        .control-panel, .result-window {
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 100;
            user-select: none;
            cursor: default;
        }
        .control-panel {
            top: 10px;
            left: 10px;
            width: 300px;
            max-height: 95vh;
            overflow-y: auto;
        }
        .result-window {
            top: 10px;
            right: 10px;
            width: 300px;
            transition: opacity 0.3s;
        }
        #profile-popup {
            display: none;
            flex-direction: column;
            bottom: 10px;
            left: 330px;
            width: 60vw;
            height: 500px;
            z-index: 110;
        }
        #profile-charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex-grow: 1;
        }
        .chart-container {
            position: relative;
            height: 100%;
            width: 100%;
        }
        .info-table th, .info-table td {
            padding: 2px 5px;
            font-size: 0.9em;
        }
        .azimuth-angle { color: #007bff; font-weight: bold; }
        .elevation-angle { color: #28a745; font-weight: bold; }
        .los-text { color: green; font-weight: bold; }
        .nlos-text { color: red; font-weight: bold; }
        .result-window-header {
            cursor: move;
            font-weight: bold;
            padding-bottom: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
        }
        .result-window-closer {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 1.2em;
            color: #aaa;
            line-height: 1;
        }
        .result-window-closer:hover {
            color: #333;
        }

        /* リサイズカーソル */
        .result-window {
            resize: none; /* CSSのresizeプロパティを無効化 */
        }
        .result-window.top-zindex { z-index: 200; }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="control-panel" class="control-panel">
        <h3 style="margin-top: 0;">伝搬計算設定</h3>

        <div style="margin-bottom: 10px;">
            <strong>プリセット:</strong>
            <button class="preset-btn" data-scenario="wlan" style="margin-left: 5px;">Wi-Fi (2.4GHz)</button>
            <button class="preset-btn" data-scenario="lte">LTE (800MHz)</button>
        </div>

        <fieldset>
            <legend>共通設定</legend>
            <label for="k-factor">K-ファクター (K):</label>
            <select id="k-factor" style="width: 100%;">
                <option value="1.0">1.0 (視覚的LOS)</option>
                <option value="1.333" selected>4/3 (標準大気)</option>
                <option value="0.8">0.8 (悪条件)</option>
            </select>
            <label for="freq-mhz">周波数 (MHz):</label>
            <input type="number" id="freq-mhz" value="1000" min="10" style="width: 100%;">
        </fieldset>

        <fieldset>
            <legend>Tx/Rx 設定</legend>
            <label for="tx-height-m">Tx 空中線高 (m):</label>
            <input type="number" id="tx-height-m" value="30" min="0.1" style="width: 100%;">
            <label for="rx-height-m">Rx 空中線高 (m):</label>
            <input type="number" id="rx-height-m" value="30" min="0.1" style="width: 100%;">
            <hr>
            <label for="tx-power-dbm">Tx 出力 (dBm):</label>
            <input type="number" id="tx-power-dbm" value="30" style="width: 100%;">
            <label for="tx-gain-dbi">Tx 利得 (dBi):</label>
            <input type="number" id="tx-gain-dbi" value="15" style="width: 100%;">
            <label for="tx-cable-loss-db">Tx ケーブル損失 (dB):</label>
            <input type="number" id="tx-cable-loss-db" value="1.5" min="0" style="width: 100%;">
            <hr>
            <label for="rx-gain-dbi">Rx 利得 (dBi):</label>
            <input type="number" id="rx-gain-dbi" value="15" style="width: 100%;">
            <label for="rx-cable-loss-db">Rx ケーブル損失 (dB):</label>
            <input type="number" id="rx-cable-loss-db" value="1.5" min="0" style="width: 100%;">
        </fieldset>

        <button id="simple-recalculate-btn" style="width: 100%; padding: 10px; margin-top: 10px; font-weight: bold;">設定で再計算</button>

        <fieldset style="margin-top: 10px;">
            <legend>地図切替</legend>
            <p style="margin: 5px 0 2px 0; font-size: 0.9em;">地図タイプ:</p>
            <label><input type="radio" name="base_type" value="std" checked> 標準地図</label>
            <label><input type="radio" name="base_type" value="photo"> 写真</label><br>
            <p style="margin: 5px 0 2px 0; font-size: 0.9em;">タイルソース:</p>
            <label><input type="radio" name="tile_source" value="gsi" checked> 地理院</label>
            <label><input type="radio" name="tile_source" value="osm"> OSM</label>
        </fieldset>
    </div>

    <div id="popup" class="result-window">
        <div class="result-window-header">結果サマリー</div>
        <a href="#" id="popup-closer" class="result-window-closer">&times;</a>
        <div id="content"><h4>計測・座標情報</h4><p>地図上の1点目をクリックしてください。</p></div>
    </div>

    <div id="profile-popup" class="result-window">
        <div class="result-window-header">
            プロファイルとレベル情報 (<span id="profile-status">未計測</span>)
        </div>
        <a href="#" id="profile-closer" class="result-window-closer">&times;</a>

        <div id="profile-charts">
            <div class="chart-container"><canvas id="elevation-chart"></canvas></div>
            <div class="chart-container"><canvas id="level-diagram-chart"></canvas></div>
        </div>
    </div>

    <script>
        const ELEVATION_API_URL = 'https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php';
        const DEFAULT_PROFILE_STEPS = 500;
        const API_TIMEOUT_MS = 10000;
        const PROJ_WGS84 = "EPSG:4326";
        const EARTH_RADIUS_M = 6371000;
        const W_TO_DBM = (W) => 10 * Math.log10(W * 1000);
        const elevationCache = new Map(); // 標高キャッシュ

        let lastDistanceMeters = 0;
        // 富士山付近のデフォルト座標
        const DEFAULT_TX_LONLAT = [138.80772, 35.19829]; // Tx: 須走口五合目付近
        const DEFAULT_RX_LONLAT = [138.75167, 35.34000]; // Rx: 富士宮口五合目付近

        // ----------------------------------------------------------------------------------------------------------------
        // [修正箇所] 閾値と線形補間ロジックの定義
        // ----------------------------------------------------------------------------------------------------------------
        // 補間方式を切り替える距離の閾値 (3000 kmをメートルに変換)
        const DISTANCE_THRESHOLD_M = 3000 * 1000;

        // WGS84座標での線形補間 (短距離で使用)
        const linearInterpolate = (coord1, coord2, fraction) => {
            // coord: [Lon, Lat]
            const lon = coord1[0] + (coord2[0] - coord1[0]) * fraction;
            const lat = coord1[1] + (coord2[1] - coord1[1]) * fraction;
            return [lon, lat];
        };
        // ----------------------------------------------------------------------------------------------------------------
        // [修正箇所 終わり]
        // ----------------------------------------------------------------------------------------------------------------

        // --- ol.sphere 測地線関数のポリフィル (変更なし) ---
        if (typeof ol.sphere === 'undefined') { ol.sphere = {}; }
        if (typeof ol.sphere.getDistance === 'undefined' || typeof ol.sphere.offset === 'undefined') {
            const R = EARTH_RADIUS_M;
            const toRadians = (deg) => deg * Math.PI / 180;
            const toDegrees = (rad) => rad * 180 / Math.PI;

            ol.sphere.getDistance = ol.sphere.getDistance || ((c1, c2) => {
                const [lon1, lat1] = c1.map(ol.math?.toRadians || toRadians);
                const [lon2, lat2] = c2.map(ol.math?.toRadians || toRadians);
                const dLat = lat2 - lat1;
                const dLon = lon2 - lon1;
                const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            });

            ol.sphere.offset = ol.sphere.offset || ((c1, distance, bearing) => {
                const [lon1, lat1] = c1.map(ol.math?.toRadians || toRadians);
                const brng = ol.math?.toRadians(bearing) || toRadians(bearing);

                const lat2 = Math.asin(Math.sin(lat1) * Math.cos(distance / R) + Math.cos(lat1) * Math.sin(distance / R) * Math.cos(brng));
                const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(distance / R) * Math.cos(lat1), Math.cos(distance / R) - Math.sin(lat1) * Math.sin(lat2));

                return [ol.math?.toDegrees(lon2) || toDegrees(lon2), ol.math?.toDegrees(lat2) || toDegrees(lat2)];
            });
        }
        // --- /ol.sphere ポリフィル終了 ---

        function calculateGreatCircleBearing(c1, c2) {
            const toRad = ol.math?.toRadians || ((deg) => deg * Math.PI / 180);
            const toDeg = ol.math?.toDegrees || ((rad) => rad * 180 / Math.PI);

            const [lon1, lat1] = c1.map(toRad);
            const [lon2, lat2] = c2.map(toRad);
            const dLon = lon2 - lon1;

            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);

            let bearingDeg = toDeg(Math.atan2(y, x));

            if (bearingDeg < 0) {
                bearingDeg += 360;
            }
            return bearingDeg;
        }

        // --- 座標変換ユーティリティ ---
        function convertToUtm(lonLatCoord) {
            try {
                const zoneNum = Math.floor((lonLatCoord[0] + 180) / 6) % 60 + 1;
                const projCode = `EPSG:326${zoneNum}`; // 北半球を想定

                // proj4に定義がない場合のみ追加
                if (!proj4.defs(projCode)) {
                     const northSouth = (lonLatCoord[1] >= 0) ? '+north' : '';
                     const projString = `+proj=utm +zone=${zoneNum} ${northSouth} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
                     proj4.defs(projCode, projString);
                }

                const utmCoord = proj4(PROJ_WGS84, projCode, lonLatCoord);
                const utmText = `${utmCoord[0].toFixed(2)}m E, ${utmCoord[1].toFixed(2)}m N (${zoneNum}${lonLatCoord[1] >= 0 ? 'N' : 'S'})`;

                return { easting: utmCoord[0], northing: utmCoord[1], code: projCode, text: utmText };
            } catch (e) {
                return { easting: 0, northing: 0, code: 'N/A', text: "N/A (UTM error)" };
            }
        }

        function convertToMGRS(lonLatCoord, precision = 5) {
            try { return mgrs.forward(lonLatCoord, precision); }
            catch (e) { return "N/A (MGRS error)"; }
        }
        // --- /座標変換ユーティリティ ---

        let map;
        let points = [];
        let features = [];
        let elevationChart;
        let levelDiagramChart;
        let profileData = null;
        const container = document.getElementById('popup');
        const content = document.getElementById('content');
        const closer = document.getElementById('popup-closer');
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');

        const getSetting = (id, defaultValue) => {
            const el = document.getElementById(id);
            if (el.type === 'number') return parseFloat(el.value) || defaultValue;
            if (el.tagName === 'SELECT') return parseFloat(el.value) || defaultValue;
            return defaultValue;
        };

        function applyPreset(scenario) {
            let freq, txPower, txGain, rxGain, txCableLoss, rxCableLoss;
            if (scenario === 'wlan') {
                freq = 2400; txPower = 20; txGain = 5; rxGain = 5; txCableLoss = 1.5; rxCableLoss = 1.5;
            } else if (scenario === 'lte') {
                freq = 800; txPower = 43; txGain = 18; rxGain = 18; txCableLoss = 2.5; rxCableLoss = 2.5;
            }
            document.getElementById('freq-mhz').value = freq;
            document.getElementById('tx-power-dbm').value = txPower;
            document.getElementById('tx-gain-dbi').value = txGain;
            document.getElementById('rx-gain-dbi').value = rxGain;
            document.getElementById('tx-cable-loss-db').value = txCableLoss;
            document.getElementById('rx-cable-loss-db').value = rxCableLoss;

            if (points.length === 2) { executeRecalculation(); }
        }

        const gsiStdLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', attributions: '地理院タイル' }), visible: true });
        const gsiPhotoLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', attributions: '地理院タイル (写真)' }), visible: false });
        const osmLayer = new ol.layer.Tile({ source: new ol.source.OSM(), visible: false });
        const baseLayerGroup = new ol.layer.Group({ layers: [gsiStdLayer, gsiPhotoLayer, osmLayer] });

        const profileVectorSource = new ol.source.Vector();
        const profileVectorLayer = new ol.layer.Vector({
            source: profileVectorSource,
            style: new ol.style.Style({
                image: new ol.style.Circle({ radius: 3, fill: new ol.style.Fill({ color: 'yellow' }), stroke: new ol.style.Stroke({ color: 'black', width: 1 }) })
            }),
            zIndex: 10
        });

        const vectorSource = new ol.source.Vector({ features: features });
        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.getGeometry().getType() === 'Point') {
                    return new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({ color: 'red' }), stroke: new ol.style.Stroke({ color: 'white', width: 2 }) }) });
                } else if (feature.getGeometry().getType() === 'LineString') {
                    return new ol.style.Style({ stroke: new ol.style.Stroke({ color: '#ff0000', width: 3, lineDash: [6, 6] }) });
                }
            },
            zIndex: 20
        });

        map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, profileVectorLayer, vectorLayer],
            view: new ol.View({ center: ol.proj.fromLonLat(DEFAULT_TX_LONLAT), zoom: 12 })
        });

        // ----------------------------------------------------------------------------------------------------------------
        // [修正箇所] 座標補間関数を距離による自動切り替えロジックに修正
        // ----------------------------------------------------------------------------------------------------------------
        function interpolateCoordinates(coord1, coord2, fraction) {
            const distance = ol.sphere.getDistance(coord1, coord2);

            if (distance <= DISTANCE_THRESHOLD_M) {
                // 短距離 (350km以下): ロバストな線形補間を採用
                return linearInterpolate(coord1, coord2, fraction);
            } else {
                // 長距離 (350km超): 既存の球面補間ロジック（大圏コース）を採用
                let bearing = calculateGreatCircleBearing(coord1, coord2);

                // calculateGreatCircleBearingが逆方位角を返すため、180度反転させて正しい方向へオフセット
                bearing = (bearing + 180) % 360;

                const interpolatedDistance = distance * fraction;
                return ol.sphere.offset(coord1, interpolatedDistance, bearing);
            }
        }
        // ----------------------------------------------------------------------------------------------------------------
        // [修正箇所 終わり]
        // ----------------------------------------------------------------------------------------------------------------

        /**
         * 標高単点取得 (キャッシュ対応)
         */
        async function getElevation(coord) {
            const lon = coord[0];
            const lat = coord[1];
            const cacheKey = `${lon.toFixed(5)},${lat.toFixed(5)}`;

            if (elevationCache.has(cacheKey)) { return elevationCache.get(cacheKey); }

            const url = `${ELEVATION_API_URL}?lon=${lon.toFixed(5)}&lat=${lat.toFixed(5)}`;

            let elevation = 0;
            try {
                const response = await fetch(url, { signal: AbortSignal.timeout(API_TIMEOUT_MS) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                elevation = data.elevation !== null && data.elevation !== undefined ? parseFloat(data.elevation) : 0;

                if (elevation === -9999 || isNaN(elevation)) { elevation = 0; }
            } catch (e) {
                elevation = 0;
            }

            elevationCache.set(cacheKey, elevation);
            return elevation;
        }

        /**
         * 標高プロファイル取得
         */
        async function getElevationProfile(coord1, coord2, maxSteps = DEFAULT_PROFILE_STEPS) {
            profileVectorSource.clear();
            const originalRxCoord = coord2;
            const distanceMeters = ol.sphere.getDistance(coord1, originalRxCoord);
            lastDistanceMeters = distanceMeters;

            // 距離に応じてステップ数を調整
            const steps = Math.max(10, Math.min(maxSteps, Math.ceil(distanceMeters / (distanceMeters > 50000 ? 200 : 40))));
            const profile = [];

            profileStatus.textContent = `座標を${steps + 1}点分リストアップ中...`;

            for (let i = 0; i <= steps; i++) {
                const fraction = i / steps;

                // 距離による自動切り替え補間を使用
                const coord = interpolateCoordinates(coord1, originalRxCoord, fraction);

                const webMercatorCoord = ol.proj.fromLonLat(coord);
                profileStatus.textContent = `標高データを取得中 (${i + 1}/${steps + 1}点)...`;

                const elevation = await getElevation(coord);

                const pointFeature = new ol.Feature({
                    geometry: new ol.geom.Point(webMercatorCoord),
                    type: 'ProfilePoint'
                });
                profileVectorSource.addFeature(pointFeature);

                profile.push({ coord, webMercatorCoord, elevation, distance: distanceMeters * fraction });
            }

            if (profile.length < 2) {
                profileStatus.textContent = `エラー: 標高データが期待通りの数だけ返されませんでした。`;
                return null;
            }

            profileStatus.textContent = `標高データ取得完了。`;
            profileData = profile;
            return profile;
        }

        // --- 伝搬計算ユーティリティ (変更なし) ---
        function calculateFSPL(distanceMeters, frequencyMhz) {
            const distanceKm = distanceMeters / 1000;
            return 32.45 + 20 * Math.log10(frequencyMhz) + 20 * Math.log10(distanceKm);
        }

        function calculateEffectiveEarthRadius(K) { return K * EARTH_RADIUS_M; }

        function calculateFresnelRadius(d1, d2, lambda) {
            if (d1 === 0 || d2 === 0) return 0;
            return Math.sqrt((lambda * d1 * d2) / (d1 + d2));
        }

        function calculatePropagation(profile, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb) {
            if (!profile || profile.length < 2) return null;

            const totalDistance = lastDistanceMeters;
            const K = parseFloat(K_FACTOR);
            const Re = calculateEffectiveEarthRadius(K);
            const lambda = 299792458 / (freqMhz * 1e6);

            let visualLos = true;
            let propLos = true;
            let minVisualClearance = Infinity;
            let minPropClearance = Infinity;
            let minF1Margin = Infinity;
            let totalMaxHeight = -Infinity;

            const txElevation = profile[0].elevation;
            const rxElevation = profile[profile.length - 1].elevation;
            const txTotalHeight = txElevation + txHeightM;
            const rxTotalHeight = rxElevation + rxHeightM;

            const txCoord = profile[0].coord;
            const rxCoord = profile[profile.length - 1].coord;

            // ベアリング計算
            const rxToTxBearing = calculateGreatCircleBearing(txCoord, rxCoord);
            const txToRxBearing = calculateGreatCircleBearing(rxCoord, txCoord);
            const txAzimuth = txToRxBearing;
            const rxAzimuth = rxToTxBearing;


            for (let i = 0; i < profile.length; i++) {
                const p = profile[i];
                const d = p.distance;
                const d_rem = totalDistance - d;

                const isIntermediate = d > 0 && d < totalDistance;

                // 視覚的LOS (K=1.0)
                const correctionVisual = (d * d_rem) / (2 * calculateEffectiveEarthRadius(1.0));
                const baseVisual = txTotalHeight + (rxTotalHeight - txTotalHeight) * (d / totalDistance);
                const heightVisual = baseVisual + correctionVisual;
                p.clearanceVisual = (p.elevation - heightVisual) * -1;
                if (isIntermediate) {
                    minVisualClearance = Math.min(minVisualClearance, p.clearanceVisual);
                    if (p.clearanceVisual < 0) visualLos = false;
                }

                // 伝搬LOS (K=K_FACTOR)
                const correctionProp = (d * d_rem) / (2 * Re);
                const baseProp = txTotalHeight + (rxTotalHeight - txTotalHeight) * (d / totalDistance);
                const heightProp = baseProp + correctionProp;
                p.heightProp = heightProp;

                const F1 = calculateFresnelRadius(d, d_rem, lambda);
                p.F1 = F1;

                p.clearanceProp = (p.elevation - heightProp) * -1;
                p.F1Margin = p.clearanceProp - F1;

                if (isIntermediate) {
                    minPropClearance = Math.min(minPropClearance, p.clearanceProp);
                    minF1Margin = Math.min(minF1Margin, p.F1Margin);
                    if (p.clearanceProp < 0) propLos = false;
                }

                totalMaxHeight = Math.max(totalMaxHeight, p.elevation);
            }

            const freespaceLossDb = calculateFSPL(totalDistance, freqMhz);
            let additionalLossDb = 0.00;
            let lossType = '自由空間損失 (FSPL)';

            if (minF1Margin < 0 || propLos === false) {
                 lossType = 'FSPL + NLOS/F1干渉';
            }

            const totalLossDb = freespaceLossDb + additionalLossDb;
            const rxPowerDbm = txPowerDbm + txGainDbi + rxGainDbi - totalLossDb - txCableLossDb - rxCableLossDb;

            const txToRxAngleRad = Math.atan2(rxTotalHeight - txTotalHeight + (totalDistance * totalDistance) / (2 * Re), totalDistance);
            const rxToTxAngleRad = Math.atan2(txTotalHeight - rxTotalHeight + (totalDistance * totalDistance) / (2 * Re), totalDistance);
            const txToRxAngleDeg = ol.math.toDegrees(txToRxAngleRad);
            const rxToTxAngleDeg = ol.math.toDegrees(rxToTxAngleRad) * -1;

            const losLineCoords = profile.map(p => [p.distance, p.heightProp]);
            const f1UpperCoords = profile.map(p => [p.distance, p.heightProp + p.F1]);
            const f1LowerCoords = profile.map(p => [p.distance, p.heightProp - p.F1]);

            const result = {
                distance: totalDistance, txHeight: txHeightM, rxHeight: rxHeightM, kFactor: K_FACTOR, frequencyMhz: freqMhz,
                txPowerDbm: txPowerDbm, txGainDbi: txGainDbi, rxGainDbi: rxGainDbi, txCableLossDb: txCableLossDb, rxCableLossDb: rxCableLossDb,
                rxPowerDbm: rxPowerDbm, visualLos: visualLos, propLos: propLos, minVisualClearance: minVisualClearance, minPropClearance: minPropClearance,
                minF1Margin: minF1Margin, totalLossDb: totalLossDb, ad_loss: additionalLossDb, losLineCoords: losLineCoords,
                f1UpperCoords: f1UpperCoords, f1LowerCoords: f1LowerCoords, totalMaxHeight: totalMaxHeight, lossType: lossType,
                txAngle: txToRxAngleDeg, rxAngle: rxToTxAngleDeg, freespaceLossDb: freespaceLossDb, txAzimuth: txAzimuth, rxAzimuth: rxAzimuth
            };
            return result;
        }
        // --- /伝搬計算ユーティリティ ---

        function addPointFeature(coord) {
            const feature = new ol.Feature({ geometry: new ol.geom.Point(coord) });
            vectorSource.addFeature(feature);
            features.push(feature);

            if (points.length === 2 && features.length === 2) {
                const txWebMercator = ol.proj.fromLonLat(points[0]);
                const rxWebMercator = ol.proj.fromLonLat(points[1]);
                const line = new ol.Feature({ geometry: new ol.geom.LineString([txWebMercator, rxWebMercator]) });
                vectorSource.addFeature(line);
                features.push(line);
            }
        }

        function displayMeasurementResults(propResults, profile) {
            // ... (表示ロジックは省略 - 変更なし) ...
            const distanceText = (propResults.distance / 1000).toFixed(3) + ' km';
            const txElevation = profile[0].elevation;
            const rxElevation = profile[profile.length - 1].elevation;
            const txTotalHeight = txElevation + propResults.txHeight;
            const rxTotalHeight = rxElevation + propResults.rxHeight;
            const txCoord = points[0];
            const rxCoord = points[1];
            const txUtm = convertToUtm(txCoord);
            const rxUtm = convertToUtm(rxCoord);
            const txMgrsText = convertToMGRS(txCoord, 5);
            const rxMgrsText = convertToMGRS(rxCoord, 5);
            const maxElevation = propResults.totalMaxHeight;
            const txAngleText = propResults.txAngle.toFixed(3) + ' °';
            const rxAngleText = propResults.rxAngle.toFixed(3) + ' °';
            const txAzimuthText = propResults.txAzimuth.toFixed(3) + ' °';
            const rxAzimuthText = propResults.rxAzimuth.toFixed(3) + ' °';
            const txDir = propResults.txAngle >= 0 ? '仰角' : '俯角';
            const rxDir = propResults.rxAngle >= 0 ? '仰角' : '俯角';
            const K_SELECTED = propResults.kFactor;
            const txEirp = propResults.txPowerDbm - propResults.txCableLossDb + propResults.txGainDbi;
            const rxGainText = `${propResults.rxGainDbi.toFixed(1)} dBi`;
            const txCableLossText = `${propResults.txCableLossDb.toFixed(1)} dB`;
            const rxCableLossText = `${propResults.rxCableLossDb.toFixed(1)} dB`;

            let headerHtml = `
                <h4>計測・座標情報</h4>
                <p><strong>2点間距離:</strong> ${distanceText}</p>
                <p><strong>最高標高:</strong> <strong style="color: ${maxElevation > 3000 ? 'green' : 'red'};">${maxElevation.toFixed(1)} m</strong></p>
                <table style="width: 100%; border-collapse: collapse;">
                    <thead><tr style="border-bottom: 1px solid #ccc;"><th style="text-align: left; padding: 3px 0;">項目</th><th style="text-align: right; padding: 3px 0;">送信点 (Tx)</th><th style="text-align: right; padding: 3px 0;">受信点 (Rx)</th></tr></thead>
                    <tbody>
                        <tr><td style="text-align: left;">緯度/経度 (WGS84)</td><td style="text-align: right;">${txCoord[1].toFixed(5)}, ${txCoord[0].toFixed(5)}</td><td style="text-align: right;">${rxCoord[1].toFixed(5)}, ${rxCoord[0].toFixed(5)}</td></tr>
                        <tr><td style="text-align: left;">MGRS (グリッド)</td><td style="text-align: right;">${txMgrsText}</td><td style="text-align: right;">${rxMgrsText}</td></tr>
                        <tr><td style="text-align: left;">UTM (ユニバーサル横メルカトル)</td><td style="text-align: right;">${txUtm.text}</td><td style="text-align: right;">${rxUtm.text}</td></tr>
                        <tr style="border-top: 1px dashed #eee;"><td style="text-align: left;">地表面標高 (m)</td><td style="text-align: right;">${txElevation.toFixed(1)} m</td><td style="text-align: right;">${rxElevation.toFixed(1)} m</td></tr>
                        <tr><td style="text-align: left;">空中線高 (m)</td><td style="text-align: right;">${propResults.txHeight.toFixed(1)} m</td><td style="text-align: right;">${propResults.rxHeight.toFixed(1)} m</td></tr>
                        <tr><td style="text-align: left;">絶対高 (m)</td><td style="text-align: right;">${txTotalHeight.toFixed(1)} m</td><td style="text-align: right;">${rxTotalHeight.toFixed(1)} m</td></tr>
                    </tbody>
                </table>
                <hr>
                <h4>アンテナ調整角度 (K=${K_SELECTED})</h4>
                <p><strong>Tx 設定方位角 (Rxへ):</strong> <span class="azimuth-angle">${txAzimuthText}</span></p>
                <p><strong>Tx 設定仰角:</strong> <span class="elevation-angle">${txAngleText} (${txDir})</span></p>
                <hr style="margin: 5px 0;">
                <p><strong>Rx 設定方位角 (Txへ):</strong> <span class="azimuth-angle">${rxAzimuthText}</span></p>
                <p><strong>Rx 設定仰角:</strong> <span class="elevation-angle">${rxAngleText} (${rxDir})</span></p>
                <hr>
            `;

            const visualLosText = propResults.visualLos ? '見通しあり (LOS)' : '遮蔽あり (NLOS)';
            const visualLosClass = propResults.visualLos ? 'los-text' : 'nlos-text';
            const visualClearanceText = propResults.minVisualClearance.toFixed(3) + ' m';

            const propLosText = propResults.propLos ? '見通しあり (LOS)' : '遮蔽あり (NLOS)';
            const propLosClass = propResults.propLos ? 'los-text' : 'nlos-text';
            const propClearanceText = propResults.minPropClearance.toFixed(3) + ' m';

            const marginText = propResults.minF1Margin.toFixed(3) + ' m ' + (propResults.minF1Margin >= 0 ? '(クリア)' : '(干渉/遮蔽)');

            let propHtml = `
                <h4>伝搬計算結果</h4>
                <p><strong>適用モデル:</strong> <strong style="color: ${propResults.ad_loss > 0 || propResults.propLos === false ? 'darkorange' : 'green'};">${propResults.lossType}</strong></p>
                <p><strong>① 幾何学的LOS (目視, K=1.0):</strong> <span class="${visualLosClass}">${visualLosText}</span></p>
                <p style="margin-left: 15px; font-size: 0.9em;"><strong>(最小クリアランス:</strong> ${visualClearanceText})</p>
                <p><strong>② 幾何学的LOS (伝搬, K=${K_SELECTED}):</strong> <span class="${propLosClass}">${propLosText}</span></p>
                <p style="margin-left: 15px; font-size: 0.9em;"><strong>(最小クリアランス:</strong> ${propClearanceText})</p>
                <p><strong>③ 最小F1マージン (伝搬):</strong> ${marginText}</p>
                <hr style="margin: 5px 0;">
                <p><strong>自由空間損失 (FSPL):</strong> ${propResults.freespaceLossDb.toFixed(2)} dB</p>
                <p><strong>追加損失 (Ad / Two-Ray):</strong> ${propResults.ad_loss.toFixed(2)} dB</p>
                <p><strong>総ケーブル損失:</strong> ${(propResults.txCableLossDb + propResults.rxCableLossDb).toFixed(1)} dB</p>
                <p><strong>全伝搬損失 (dB):</strong> ${propResults.totalLossDb.toFixed(2)} dB</p>
                <p><strong>受信電力 (dBm):</strong> <strong style="color: ${propResults.rxPowerDbm > -80 ? 'green' : 'red'};">${propResults.rxPowerDbm.toFixed(2)} dBm</strong></p>
            `;

            content.innerHTML = `
                ${headerHtml}
                <h4>送信局 (Tx) 設定</h4>
                <p><strong>Tx EIRP (空中線より放射):</strong> ${txEirp.toFixed(1)} dBm</p>
                <p><strong>Tx 出力 (無線機):</strong> ${propResults.txPowerDbm.toFixed(1)} dBm</p>
                <p><strong>Tx ケーブル損失:</strong> ${txCableLossText}</p>
                <hr>
                <h4>受信局 (Rx) 設定</h4>
                <p><strong>Rx ケーブル損失:</strong> ${rxCableLossText}</p>
                <p><strong>Rx 利得:</strong> ${rxGainText}</p>
                ${propHtml}
            `;
            container.style.display = 'block';
        }

        function updateElevationChart(profile, propResults) {
            // ... (チャート更新ロジックは省略 - 変更なし) ...
            const data = profile.map(p => ({ x: p.distance / 1000, y: p.elevation }));
            const distanceLabels = profile.map(p => (p.distance / 1000).toFixed(2));
            const txRxPoints = [{ x: 0, y: profile[0].elevation + propResults.txHeight },
                                { x: propResults.distance / 1000, y: profile[profile.length - 1].elevation + propResults.rxHeight }];
            const losData = propResults.losLineCoords.map(c => ({ x: c[0] / 1000, y: c[1] }));
            const f1UpperData = propResults.f1UpperCoords.map(c => ({ x: c[0] / 1000, y: c[1] }));
            const f1LowerData = propResults.f1LowerCoords.map(c => ({ x: c[0] / 1000, y: c[1] }));

            const minElev = Math.min(...data.map(d => d.y), ...f1LowerData.map(d => d.y), -10) - 10;
            const maxElev = Math.max(...f1UpperData.map(d => d.y), propResults.totalMaxHeight, 50) + 10;

            const chartConfig = {
                type: 'line',
                data: {
                    labels: distanceLabels,
                    datasets: [
                        { label: '地表標高 (DEM)', data: data, borderColor: 'rgb(102, 51, 0)', backgroundColor: 'rgba(102, 51, 0, 0.5)', borderWidth: 1, pointRadius: 0, fill: 'origin', yAxisID: 'y' },
                        { label: 'F1ゾーン下部ライン', data: f1LowerData, borderColor: 'rgb(255, 165, 0)', borderDash: [5, 5], backgroundColor: 'rgba(0, 0, 0, 0)', borderWidth: 2, pointRadius: 0, fill: false, yAxisID: 'y' },
                        { label: 'F1ゾーン (K='+propResults.kFactor+')', data: f1UpperData, borderColor: 'transparent', borderWidth: 0, backgroundColor: 'rgba(255, 165, 0, 0.2)', pointRadius: 0, fill: { target: 'stack', group: 'F1Zone', above: 'F1ゾーン下部ライン' }, yAxisID: 'y' },
                        { label: 'LOSライン (K='+propResults.kFactor+')', data: losData, borderColor: 'rgb(0, 0, 255)', borderWidth: 1, pointRadius: 0, fill: false, yAxisID: 'y' }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: '距離 (km)' }, type: 'linear', min: 0, max: propResults.distance / 1000 },
                        y: {
                            title: { display: true, text: '高さ (m)' },
                            min: minElev,
                            max: maxElev,
                            ticks: { callback: function(value) { return value + ' m'; } }
                        }
                    },
                    plugins: {
                        legend: { display: true },
                        title: { display: true, text: `標高プロファイル (K=${propResults.kFactor})` },
                        annotation: {
                            annotations: {
                                txPoint: { type: 'point', xValue: 0, yValue: txRxPoints[0].y, radius: 5, backgroundColor: 'red', label: { content: 'Tx', display: true, position: 'start' } },
                                rxPoint: { type: 'point', xValue: txRxPoints[1].x, yValue: txRxPoints[1].y, radius: 5, backgroundColor: 'blue', label: { content: 'Rx', display: true, position: 'start' } }
                            }
                        }
                    }
                }
            };

            const ctx = document.getElementById('elevation-chart').getContext('2d');
            if (elevationChart) { elevationChart.destroy(); }
            elevationChart = new Chart(ctx, chartConfig);
        }

        function updateLevelDiagramChart(propResults) {
            // ... (レベルダイヤグラム更新ロジックは省略 - 変更なし) ...
            const level1 = propResults.txPowerDbm;
            const level2 = level1 - propResults.txCableLossDb;
            const level3 = level2 + propResults.txGainDbi;
            const level4 = level3 - propResults.freespaceLossDb;
            const level5 = level4 + propResults.rxGainDbi;
            const level6 = level5 - propResults.rxCableLossDb;

            const labels = ['送信出力', 'Tx Ant入力\n(ケーブルロス)', 'Tx EIRP\n(Tx利得)', 'Rx Ant入力\n(空間損失)', 'Rx Ant出力\n(Rx利得)', '受信機入力\n(ケーブルロス)'];
            const dataLevels = [level1, level2, level3, level4, level5, level6];
            const minLevel = Math.min(...dataLevels, -100) - 5;
            const maxLevel = Math.max(...dataLevels, 50) + 5;

            const chartData = {
                labels: labels,
                datasets: [{
                        label: '電力レベル (dBm)',
                        data: dataLevels,
                        borderColor: 'rgb(0, 0, 255)',
                        backgroundColor: 'rgba(0, 0, 255, 0.2)',
                        borderWidth: 3,
                        pointRadius: 6,
                        fill: false,
                        tension: 0,
                        yAxisID: 'y'
                    }]
            };

            const chartConfig = {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: '伝送経路の段階' }, type: 'category', grid: { display: false }, ticks: { callback: function(value, index) { return this.getLabelForValue(value).split('\n'); } } } ,
                        y: { title: { display: true, text: '電力レベル (dBm)' }, min: minLevel, max: maxLevel, ticks: { callback: function(value) { return value.toFixed(2) + ' dBm'; } } }
                    },
                    plugins: { legend: { display: false }, title: { display: true, text: 'レベルダイヤグラム (折れ線グラフ)' }, tooltip: { callbacks: { label: function(context) { return ` ${context.parsed.y.toFixed(2)} dBm`; } } } }
                }
            };

            const ctx = document.getElementById('level-diagram-chart').getContext('2d');
            if (levelDiagramChart) { levelDiagramChart.destroy(); }
            levelDiagramChart = new Chart(ctx, chartConfig);
        }

        // ... (processMeasurement, resetMeasurement, executeRecalculation, ドラッグ/リサイズ機能、地図切り替え機能は変更なし) ...
        async function processMeasurement() {
            if (points.length !== 2) return;
            const profile = await getElevationProfile(points[0], points[1]);
            if (!profile) return;
            const K_FACTOR = getSetting('k-factor', 1.333);
            const freqMhz = getSetting('freq-mhz', 1000);
            const txHeightM = getSetting('tx-height-m', 30);
            const rxHeightM = getSetting('rx-height-m', 30);
            const txPowerDbm = getSetting('tx-power-dbm', 30);
            const txGainDbi = getSetting('tx-gain-dbi', 15);
            const rxGainDbi = getSetting('rx-gain-dbi', 15);
            const txCableLossDb = getSetting('tx-cable-loss-db', 1.5);
            const rxCableLossDb = getSetting('rx-cable-loss-db', 1.5);
            const propResults = calculatePropagation(profile, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb);
            if (propResults) {
                displayMeasurementResults(propResults, profile);
                updateElevationChart(profile, propResults);
                updateLevelDiagramChart(propResults);
                profileContainer.style.display = 'flex';
                if (elevationChart) elevationChart.resize();
                if (levelDiagramChart) levelDiagramChart.resize();
            } else { content.innerHTML = `<h4>エラー</h4><p>伝搬計算に失敗しました。</p>`; }
        }

        function resetMeasurement(resetCoord = true) {
            if (resetCoord) { points = []; }
            vectorSource.clear(); profileVectorSource.clear(); features = [];
            container.style.display = 'none'; profileContainer.style.display = 'none';
            content.innerHTML = `<h4>計測・座標情報</h4><p>地図上の1点目をクリックしてください。</p>`;
            profileData = null; elevationCache.clear(); profileStatus.textContent = '未計測'; lastDistanceMeters = 0;
            if (points.length === 2) {
                const txWebMercator = ol.proj.fromLonLat(points[0]);
                const rxWebMercator = ol.proj.fromLonLat(points[1]);
                addPointFeature(txWebMercator); addPointFeature(rxWebMercator);
            }
        }

        function executeRecalculation() {
            if (points.length === 2 && profileData && lastDistanceMeters > 0) {
                profileVectorSource.clear();
                for (const p of profileData) {
                    const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(p.webMercatorCoord), type: 'ProfilePoint' });
                    profileVectorSource.addFeature(pointFeature);
                }
                const K_FACTOR = getSetting('k-factor', 1.333);
                const freqMhz = getSetting('freq-mhz', 1000);
                const txHeightM = getSetting('tx-height-m', 30);
                const rxHeightM = getSetting('rx-height-m', 30);
                const txPowerDbm = getSetting('tx-power-dbm', 30);
                const txGainDbi = getSetting('tx-gain-dbi', 15);
                const rxGainDbi = getSetting('rx-gain-dbi', 15);
                const txCableLossDb = getSetting('tx-cable-loss-db', 1.5);
                const rxCableLossDb = getSetting('rx-cable-loss-db', 1.5);
                const propResults = calculatePropagation(profileData, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb);
                if (propResults) {
                    displayMeasurementResults(propResults, profileData);
                    updateElevationChart(profileData, propResults);
                    updateLevelDiagramChart(propResults);
                    if (elevationChart) elevationChart.resize();
                    if (levelDiagramChart) levelDiagramChart.resize();
                }
            } else if (points.length === 2) { processMeasurement(); }
        }

        // (ドラッグ/リサイズ機能の関数定義はコードの可読性のため省略)

        // --- イベントリスナーの登録 ---

        document.getElementById('simple-recalculate-btn').addEventListener('click', executeRecalculation);
        document.querySelectorAll('.preset-btn').forEach(button => {
            button.addEventListener('click', (event) => {
                const scenario = event.currentTarget.getAttribute('data-scenario');
                applyPreset(scenario);
            });
        });

        // ドラッグ/リサイズ関連のイベントリスナー
        // (関数定義は省略しましたが、ここでイベントを登録しています)
        container.addEventListener('mousedown', event => startDrag(event, container));
        container.addEventListener('touchstart', event => startDrag(event, container), { passive: false });
        profileContainer.addEventListener('mousedown', event => startDrag(event, profileContainer));
        profileContainer.addEventListener('touchstart', event => startDrag(event, profileContainer), { passive: false });
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', stopDrag);

        closer.onclick = function() { resetMeasurement(); return false; };
        profileCloser.onclick = function() { profileContainer.style.display = 'none'; return false; };

        function handleBaseMapChange() {
            const baseType = document.querySelector('input[name="base_type"]:checked').value;
            let tileSource = document.querySelector('input[name="tile_source"]:checked').value;
            if (baseType === 'photo') { tileSource = 'gsi'; }
            baseLayerGroup.getLayers().forEach(layer => layer.setVisible(false));
            if (baseType === 'std') {
                if (tileSource === 'osm') { osmLayer.setVisible(true); }
                else if (tileSource === 'gsi') { gsiStdLayer.setVisible(true); }
            } else if (baseType === 'photo') { gsiPhotoLayer.setVisible(true); }
        }

        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') { handleBaseMapChange(); }
        });

        map.on('click', async (evt) => {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);
            if (points.length >= 2) resetMeasurement();
            points.push(lonLatCoord);
            addPointFeature(webMercatorCoord);

            if (points.length === 2) { await processMeasurement(); }
            else {
                profileContainer.style.display = 'none';
                container.style.display = 'block';
                content.innerHTML = `<h4>計測・座標情報</h4><p>1点目座標: ${lonLatCoord[1].toFixed(5)}, ${lonLatCoord[0].toFixed(5)}</p><p>2点目をクリックして計測を開始してください。</p>`;
            }
        });

        // 初期座標を設定して自動計測を実行
        async function runInitialCalculation() {
            //points.push(DEFAULT_TX_LONLAT);
            //points.push(DEFAULT_RX_LONLAT);
            //const txWebMercator = ol.proj.fromLonLat(DEFAULT_TX_LONLAT);
            //const rxWebMercator = ol.proj.fromLonLat(DEFAULT_RX_LONLAT);
            //addPointFeature(txWebMercator);
            //addPointFeature(rxWebMercator);
            //map.getView().fit(vectorSource.getExtent(), { padding: [50, 50, 50, 50], duration: 1000 });
            //await processMeasurement();
        }

        window.onload = () => {
            resetMeasurement(false);
            handleBaseMapChange();
            runInitialCalculation();
        };

        // ... (ドラッグ/リサイズ機能のヘルパー関数は省略 - 完全なHTMLファイルに含めてください) ...
        const MIN_SIZE = 250; const EDGE_TOLERANCE = 10; let isDragging = false; let isResizing = false; let resizeDirection = ''; let startPoint; let startRect; let currentDraggingElement = null;
        function getResizeDirection(eventPoint, element) { /* ... */ } function setCursor(direction) { /* ... */ }
        function startDrag(event, targetElement) { /* ... */ } function handleDragMove(event) { /* ... */ }
        function stopDrag() { /* ... */ } function handleMouseMove(event) { /* ... */ }
    </script>
</body>
</html>
