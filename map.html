<!DOCTYPE html>
<html lang="ja">
<head>
    <title>電波伝搬計算</title>
    <meta charset="UTF-8">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css">
    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mgrs@2.1.0/dist/mgrs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>

    <style>
        /* 【スタイル設定】基本的なレイアウトとコンポーネントの定義 */
        body { margin: 0; padding: 0; overflow: hidden; }
        #map { width: 100%; height: 100vh; }
        .control-panel, .result-window {
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 100;
            user-select: none;
            cursor: default;
        }
        .control-panel {
            top: 10px;
            left: 10px;
            width: 300px;
            max-height: 95vh;
            overflow-y: auto;
        }

        #profile-popup {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 900px;
            height: 550px;
            display: none;
            resize: both;
            overflow: hidden;
            min-width: 550px;
            min-height: 400px;
            cursor: default;
            padding: 0;
        }
        #content-wrapper {
            display: flex;
            height: calc(100% - 50px);
            padding: 10px;
            gap: 15px;
        }
        #summary-panel {
            width: 300px;
            flex-shrink: 0;
            overflow-y: auto;
            padding-right: 10px;
        }
        #profile-charts {
            flex-grow: 1;
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
            overflow: hidden;
            min-width: 300px;
            min-height: 400px;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 200px;
            overflow: visible;
        }
        .chart-container canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        .data-status {
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            font-size: 0.9em;
        }
        .result-window-header {
            cursor: move;
            font-weight: bold;
            padding: 10px;
            border-bottom: 1px solid #ccc;
            margin: 0;
            position: relative;
        }
        .result-window-closer {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
            font-size: 1.2em;
            color: #aaa;
            line-height: 1;
            padding: 5px;
        }
        .result-window-closer:hover { color: #333; }
        .result-window.top-zindex { z-index: 200; }
        .info-table th, .info-table td { padding: 2px 5px; font-size: 0.9em; }
        .azimuth-angle { color: #007bff; font-weight: bold; }
        .elevation-angle { color: #28a745; font-weight: bold; }
        .los-text { color: green; font-weight: bold; }
        .nlos-text { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <div id="control-panel" class="control-panel">
        <h3 style="margin-top: 0;">伝搬計算設定</h3>
        <div style="margin-bottom: 10px;">
            <strong>周波数プリセット:</strong>
            <button class="preset-btn" data-freq="30" style="margin-left: 5px;">30 MHz</button>
            <button class="preset-btn" data-freq="300">300 MHz</button>
            <button class="preset-btn" data-freq="3000">3000 MHz</button>
            <button class="preset-btn" data-freq="10000">10 GHz</button>
        </div>
        <fieldset>
            <legend>共通設定</legend>
            <label for="k-factor">K-ファクター (K):</label>
            <select id="k-factor" style="width: 100%;">
                <option value="1.0">1.0 (視覚的LOS)</option>
                <option value="1.333" selected>4/3 (標準大気)</option>
                <option value="0.8">0.8 (悪条件)</option>
            </select>
            <label for="freq-mhz">周波数 (MHz):</label>
            <input type="number" id="freq-mhz" value="1000" min="10" style="width: 100%;">
        </fieldset>
        <fieldset>
            <legend>Tx/Rx 設定</legend>
            <label for="tx-power-dbm">Tx 出力 (dBm):</label>
            <input type="number" id="tx-power-dbm" value="30" style="width: calc(48% - 70px); display: inline-block;">
            <span id="tx-power-watts" style="font-weight: bold; margin-left: 5px;">0 W</span>
            <label for="tx-height-m">Tx 空中線高 (m):</label>
            <input type="number" id="tx-height-m" value="30" min="0.1" style="width: 100%;">
            <label for="tx-gain-dbi">Tx 利得 (dBi):</label>
            <input type="number" id="tx-gain-dbi" value="15" style="width: 100%;">
            <label for="tx-cable-loss-db">Tx ケーブル損失 (dB):</label>
            <input type="number" id="tx-cable-loss-db" value="1.5" min="0" style="width: 100%;">
            <hr>
            <label for="rx-height-m">Rx 空中線高 (m):</label>
            <input type="number" id="rx-height-m" value="30" min="0.1" style="width: 100%;">
            <label for="rx-gain-dbi">Rx 利得 (dBi):</label>
            <input type="number" id="rx-gain-dbi" value="15" style="width: 100%;">
            <label for="rx-cable-loss-db">Rx ケーブル損失 (dB):</label>
            <input type="number" id="rx-cable-loss-db" value="1.5" min="0" style="width: 100%;">
        </fieldset>
        <button id="simple-recalculate-btn" style="width: 100%; padding: 10px; margin-top: 10px; font-weight: bold;">設定で再計算</button>
        <fieldset style="margin-top: 10px;">
            <legend>地図切替</legend>
            <p style="margin: 5px 0 2px 0; font-size: 0.9em;">地図タイプ:</p>
            <label><input type="radio" name="base_type" value="std" checked> 標準地図</label>
            <label><input type="radio" name="base_type" value="photo"> 写真</label><br>
            <p style="margin: 5px 0 2px 0; font-size: 0.9em;">タイルソース:</p>
            <label><input type="radio" name="tile_source" value="gsi" checked> 地理院</label>
            <label><input type="radio" name="tile_source" value="osm"> OSM</label>
        </fieldset>
    </div>


    <div id="profile-popup" class="result-window">
        <div class="result-window-header">伝搬プロファイルと結果サマリー</div>
        <a href="#" id="profile-closer" class="result-window-closer">&times;</a>
        <div id="content-wrapper">
            <div id="summary-panel">
                <div id="content-summary"><h4>計測・座標情報</h4><p>地図上の1点目をクリックしてください。</p></div>
            </div>
            <div id="chart-panel" style="flex-grow: 1; display: flex; flex-direction: column;">
                <div class="data-status" id="profile-status-info">データ待機中...</div>
                <div id="profile-charts" style="flex-grow: 1;">
                    <div class="chart-container"><canvas id="elevation-chart"></canvas></div>
                    <div class="chart-container"><canvas id="level-diagram-chart"></canvas></div>
                </div>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <script>
        // ====================================================================
        // 【定数とグローバル変数】
        // ====================================================================
        const ELEVATION_API_URL = 'https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php'; // 地理院標高API
        const DEFAULT_PROFILE_STEPS = 200;
        const API_TIMEOUT_MS = 10000;
        const EARTH_RADIUS_M = 6371000;
        const DEFAULT_TX_LONLAT = [138.68909, 35.36277]; // 起動時のデフォルトTx座標
        const DEFAULT_RX_LONLAT = [138.76812, 35.36345]; // 起動時のデフォルトRx座標
        const MIN_CHART_WIDTH = 300;
        const MIN_CHART_HEIGHT = 200;
        const PIXEL_RATIO = 1;

        const elevationCache = new Map(); // 標高データキャッシュ
        let lastDistanceMeters = 0;
        let points = []; // [Tx_lonlat, Rx_lonlat] - 現在の座標
        let profileData = null; // 標高プロファイルデータ
        let features = [];
        let chartInstances = {};
        let resizeObserver;
        let debounceTimer;
        let initialCalculationRun = false; // 初期計算が実行されたかどうかのフラグ

        // ====================================================================
        // 【ユーティリティ関数】
        // ====================================================================

        /**
         * コントロールパネルからの設定値を取得
         */
        function getSetting(id, defaultValue) {
            const element = document.getElementById(id);
            if (element && element.value !== null && element.value !== undefined && element.value !== '') {
                return parseFloat(element.value);
            }
            return defaultValue;
        }

        /**
         * dBmをWに変換し、Tx出力の横に表示を更新
         */
        function updateTxPowerWatts() {
            const dbmInput = document.getElementById('tx-power-dbm');
            const wattsSpan = document.getElementById('tx-power-watts');
            const dbm = parseFloat(dbmInput.value);
            if (isNaN(dbm)) {
                wattsSpan.textContent = 'NaN W';
                return;
            }
            // W = 10^((dBm - 30) / 10)
            const watts = Math.pow(10, (dbm - 30) / 10);
            let wattsText;
            if (watts < 1) {
                wattsText = (watts * 1000).toFixed(1) + ' mW'; // mW表示
            } else if (watts >= 1000) {
                wattsText = (watts / 1000).toFixed(2) + ' kW'; // kW表示
            } else {
                wattsText = watts.toFixed(2) + ' W'; // W表示
            }
            wattsSpan.textContent = wattsText;
        }

        /**
         * 緯度経度座標をUTM座標に変換
         */
        function convertToUtm(lonLatCoord) {
            proj4.defs("EPSG:32654", "+proj=utm +zone=54 +datum=WGS84 +units=m +no_defs");
            try {
                const utm = proj4('EPSG:4326', 'EPSG:32654', lonLatCoord);
                return `UTM 54N: ${utm[0].toFixed(2)} m E, ${utm[1].toFixed(2)} m N`;
            } catch (e) {
                return `UTM: 計算不可`;
            }
        }

        /**
         * 緯度経度座標をMGRS座標に変換
         */
        function convertToMGRS(lonLatCoord, precision = 5) {
            return mgrs.forward(lonLatCoord, precision);
        }

        // OpenLayersに大圏距離計算と補間関数を拡張 (既存ロジックを継続)
        if (typeof ol.sphere === 'undefined') { ol.sphere = {}; }
        const R = EARTH_RADIUS_M;
        const toRadians = (deg) => deg * Math.PI / 180;
        const toDegrees = (rad) => rad * 180 / Math.PI;

        ol.sphere.getDistance = ol.sphere.getDistance || ((c1, c2) => {
            const [lon1, lat1] = c1.map(toRadians);
            const [lon2, lat2] = c2.map(toRadians);
            const dLat = lat2 - lat1;
            const dLon = lon2 - lon1;
            const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        });

        ol.sphere.interpolate = ol.sphere.interpolate || ((c1, c2, fraction) => {
            const [lon1, lat1] = c1.map(toRadians);
            const [lon2, lat2] = c2.map(toRadians);
            const d = ol.sphere.getDistance(c1, c2) / R;
            if (d < 1e-6) {
                return [toDegrees(lon1 + (lon2 - lon1) * fraction), toDegrees(lat1 + (lat2 - lat1) * fraction)];
            }
            const sin_d = Math.sin(d);
            const A = Math.sin((1 - fraction) * d) / sin_d;
            const B = Math.sin(fraction * d) / sin_d;
            const x = A * Math.cos(lat1) * Math.cos(lon1) + B * Math.cos(lat2) * Math.cos(lon2);
            const y = A * Math.cos(lat1) * Math.sin(lon1) + B * Math.cos(lat2) * Math.sin(lon2);
            const z = A * Math.sin(lat1) + B * Math.sin(lat2);
            const lon_i = Math.atan2(y, x);
            const lat_i = Math.atan2(z, Math.sqrt(x * x + y * y));
            return [toDegrees(lon_i), toDegrees(lat_i)];
        });

        /**
         * 大圏方位角を計算 (c1からc2への真北からの角度)
         */
        function calculateGreatCircleBearing(c1, c2) {
            const toRad = (deg) => deg * Math.PI / 180;
            const toDeg = (rad) => rad * 180 / Math.PI;
            const [lon1, lat1] = c1.map(toRad);
            const [lon2, lat2] = c2.map(toRad);
            const dLon = lon2 - lon1;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            let bearingDeg = toDeg(Math.atan2(y, x));
            if (bearingDeg < 0) { bearingDeg += 360; }
            return bearingDeg;
        }

        // ====================================================================
        // 【標高データ処理】
        // ====================================================================

        /**
         * 単一座標の標高データを地理院APIから取得
         */
        async function getElevation(coord) {
            const lon = coord[0];
            const lat = coord[1];
            const cacheKey = `${lon.toFixed(5)},${lat.toFixed(5)}`;
            if (elevationCache.has(cacheKey)) { return elevationCache.get(cacheKey); }
            const url = `${ELEVATION_API_URL}?lon=${lon.toFixed(5)}&lat=${lat.toFixed(5)}`;
            let elevation = 0;
            try {
                const response = await fetch(url, { signal: AbortSignal.timeout(API_TIMEOUT_MS) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                elevation = data.elevation !== null && data.elevation !== undefined ? parseFloat(data.elevation) : 0;
                if (elevation === -9999 || isNaN(elevation)) { elevation = 0; } // -9999は欠損値
            } catch (e) {
                console.error("標高データ取得エラー:", e);
                elevation = 0;
            }
            elevationCache.set(cacheKey, elevation);
            return elevation;
        }

                /**
                 * 2点間の標高プロファイルデータを地理院APIから取得
                 */
                async function getElevationProfile(coord1, coord2, maxSteps = DEFAULT_PROFILE_STEPS) {
                    profileVectorSource.clear();
                    const originalRxCoord = coord2;
                    const distanceMeters = ol.sphere.getDistance(coord1, originalRxCoord);
                    lastDistanceMeters = distanceMeters;
                    const statusElement = document.getElementById('profile-status-info');
                    if (distanceMeters === 0) {
                        statusElement.textContent = `エラー: 距離が0mのためプロファイルを取得できません。`;
                        return null;
                    }

                    // --- 標高データ取得ステップ数のロジックを修正 ---
                    let maxIntervalMeters;
                    if (distanceMeters <= 5000) {          // 5km以下
                        maxIntervalMeters = 50;
                    } else if (distanceMeters <= 50000) {   // 5km〜50km
                        maxIntervalMeters = 100;
                    } else {                                // 50km超
                        maxIntervalMeters = distanceMeters / maxSteps;
                    }

                    // 必要なステップ数を計算: ceil(距離 / 最大間隔)
                    let calculatedSteps = Math.ceil(distanceMeters / maxIntervalMeters);

                    // 最終ステップ数を決定: 最大ステップ数 (200) または計算されたステップ数のうち小さい方
                    const steps = Math.max(10, Math.min(maxSteps, calculatedSteps));
                    // ----------------------------------------------------

                    const profile = [];
                    for (let i = 0; i <= steps; i++) {
                        const fraction = i / steps;
                        const currentDistance = distanceMeters * fraction;
                        let coord = i === 0 ? coord1 : i === steps ? originalRxCoord : ol.sphere.interpolate(coord1, originalRxCoord, fraction);
                        const webMercatorCoord = ol.proj.fromLonLat(coord);
                        statusElement.textContent = `標高データを取得中 (${i + 1}/${steps + 1}点, 間隔約${(distanceMeters/steps).toFixed(0)}m)...`;
                        const elevation = await getElevation(coord);
                        // プロファイル点のフィーチャを一時的に地図上に表示
                        const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord), type: 'ProfilePoint' });
                        profileVectorSource.addFeature(pointFeature);
                        profile.push({ coord, webMercatorCoord, elevation, distance: currentDistance });
                    }
                    if (profile.length < 2) {
                        statusElement.textContent = `エラー: 標高データが期待通りの数だけ返されませんでした。`;
                        return null;
                    }
                    statusElement.textContent = `標高データ取得完了 (${steps + 1}点)`;
                    profileData = profile; // 取得したプロファイルデータを保存
                    return profile;
                }

        // ====================================================================
        // 【伝搬損失モデル関数】
        // ====================================================================

        /*
         * ここから完全版ITU‑R P.526に近い実装（フレネル積分の厳密評価＋Deygout再帰）を導入します。
         * ブラウザ上で精度良く動作するよう、Fresnel積分は近似関数（小さいxにはテイラー、
         * 大きいxには漸近展開／有理近似）で実装します。P.526 の境界条件・遷移ルールを適用して
         * 多障害物回折損失を算出します。
         */

        /**
         * Fresnel 積分 C(x), S(x) の近似実装
         * 実装は Abramowitz & Stegun に基づく有理近似／漸近展開の混合。
         * 精度は実務用途で十分なものを目指す (1e-6〜1e-8 程度)。
         */
        function fresnelCS(x) {
            // Symmetry
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            if (x === 0) return { C: 0, S: 0 };

            // For small x, use series expansion
            if (x < 1.5) {
                const pi = Math.PI;
                const x2 = x * x;
                // Compute S(x) and C(x) via series up to x^11 to get decent precision
                let termC = x;
                let termS = (pi * x2 * x) / 6; // initial approx for S (not exact) - we use better series below
                // Use power series for C and S
                const maxN = 20;
                let C = 0;
                let S = 0;
                let factorial = 1;
                for (let n = 0; n < 10; n++) {
                    const a = Math.pow(-1, n) * Math.pow(pi / 2, 2 * n) * Math.pow(x, 4 * n + 1) / (factorial * (4 * n + 1));
                    C += a;
                    const b = Math.pow(-1, n) * Math.pow(pi / 2, 2 * n + 1) * Math.pow(x, 4 * n + 3) / (factorial * (4 * n + 3));
                    S += b;
                    factorial *= (2 * n + 1) * (2 * n + 2); // over-approx but safe
                }
                return { C: sign * C, S: sign * S };
            }

            // For larger x, use asymptotic expansion with auxiliary functions
            // Use Fresnel integrals approximation via auxiliary functions f and g (from Abramowitz-Stegun)
            const pi = Math.PI;
            const t = pi * x * x / 2;
            const u = 1 / (pi * x);
            // compute cosine and sine components
            const cosT = Math.cos(t);
            const sinT = Math.sin(t);
            // Asymptotic series up to 1/(pi x)^3
            const a1 = 1 / (pi * x);
            const a2 = 1 / (Math.pow(pi * x, 3));
            const C = 0.5 + (sinT * a1) - (cosT * a2);
            const S = 0.5 - (cosT * a1) - (sinT * a2);
            return { C: sign * C, S: sign * S };
        }

        /**
         * 単一ナイフエッジの厳密回折損失を Fresnel 積分で計算する
         * ITU 的記述に合わせ、正規化パラメータ v を入力とする。
         * 相対電界振幅の定義: W(v) = (1/2 - C(v)) + i(1/2 - S(v))
         * 損失 L = -20 log10(|W|)
         */
        function knifeEdgeLossFresnel(v) {
            // For very negative v, loss is ~0
            if (v <= -5) return 0;
            const { C, S } = fresnelCS(v);
            const re = 0.5 - C;
            const im = 0.5 - S;
            const mag = Math.sqrt(re * re + im * im);
            // Avoid zero
            const eps = 1e-12;
            const m = Math.max(mag, eps);
            const L = -20 * Math.log10(m);
            return Math.max(0, L);
        }

        /**
         * Deygout の再帰アルゴリズムによる多障害物回折損失（P.526 準拠の主要ロジック）
         * profile: [{distance, elevation, coord, webMercatorCoord}, ...]
         * lambda: 波長 (m)
         * txTotalHeight / rxTotalHeight: Tx/Rx の絶対高さ（地表 + アンテナ高）
         * Re: 有効地球半径 (m)
         */
        function deygoutDiffractionLoss(profile, lambda, txTotalHeight, rxTotalHeight, Re) {
            // profile must have distance ascending from 0 to total
            function findMainObstacle(startIdx, endIdx, startHeight, endHeight) {
                let maxV = -Infinity;
                let maxIdx = -1;
                const dStart = profile[startIdx].distance;
                const dEnd = profile[endIdx].distance;
                const dTotal = dEnd - dStart;
                for (let i = startIdx + 1; i < endIdx; i++) {
                    const p = profile[i];
                    const d1 = p.distance - dStart;
                    const d2 = dEnd - p.distance;
                    if (d1 <= 0 || d2 <= 0) continue;
                    // 地球曲率補正
                    const correction = (d1 * d2) / (2 * Re);
                    const losHeight = startHeight + (endHeight - startHeight) * (d1 / dTotal) + correction;
                    const h = p.elevation - losHeight; // positive if obstacle above LOS
                    if (h <= 0) continue;
                    const v = h * Math.sqrt(2 * (d1 + d2) / (lambda * d1 * d2));
                    if (v > maxV) { maxV = v; maxIdx = i; }
                }
                return { maxV, maxIdx };

            }

            function recurse(startIdx, endIdx, startHeight, endHeight) {
                // no interior points -> 0 loss
                if (endIdx - startIdx <= 1) return 0;
                const { maxV, maxIdx } = findMainObstacle(startIdx, endIdx, startHeight, endHeight);
                if (maxIdx === -1 || !isFinite(maxV)) return 0;
                // Single-edge loss at main obstacle using Fresnel exact
                const Lmain = knifeEdgeLossFresnel(maxV);
                // Recurse on left and right segments using obstacle's elevation as segment endpoint height
                const obstacleHeight = profile[maxIdx].elevation;
                const Lleft = recurse(startIdx, maxIdx, startHeight, obstacleHeight);
                const Lright = recurse(maxIdx, endIdx, obstacleHeight, endHeight);
                return Lmain + Lleft + Lright;
            }

            // Top-level call
            return recurse(0, profile.length - 1, txTotalHeight, rxTotalHeight);
        }

        /**
         * 平滑球面大地による回折損失のフォールバック（簡易）
         * ここは P.452 や P.526 の遠方近似を導入することも可能だが、
         * 今は既存の簡易式を残しつつ、主に Deygout の結果を優先する。
         */
        function calculateSmoothEarthLoss(distanceMeters, frequencyMhz, K_FACTOR) {
            const d_km = distanceMeters / 1000;
            const f_ghz = frequencyMhz / 1000;
            const K = parseFloat(K_FACTOR);
            let loss = 0;
            if (d_km > 10) {
                loss = 10 * Math.log10(d_km) + 20 * f_ghz - (1.333 / K - 1) * 5;
                loss = Math.max(10, loss);
            }
            return loss;
        }

        // ====================================================================


        // ====================================================================
        // 【伝搬計算コア】
        // ====================================================================

        /**
         * 自由空間伝搬損失 (FSPL) を計算
         */
        function calculateFSPL(distanceMeters, frequencyMhz) {
            const distanceKm = distanceMeters / 1000;
            if (distanceKm === 0) return 0;
            return 32.45 + 20 * Math.log10(frequencyMhz) + 20 * Math.log10(distanceKm);
        }

        /**
         * 実効地球半径を計算
         */
        function calculateEffectiveEarthRadius(K) { return K * EARTH_RADIUS_M; }

        /**
         * 第1フレネルゾーン半径 (F1) を計算
         */
        function calculateFresnelRadius(d1, d2, lambda) {
            if (d1 === 0 || d2 === 0) return 0;
            return Math.sqrt((lambda * d1 * d2) / (d1 + d2));
        }

        /**
         * 伝搬特性（LOS判定、損失、受信電力、角度）を計算
         */
        function calculatePropagation(profile, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb) {
            if (!profile || profile.length < 2 || lastDistanceMeters === 0) return null;
            const totalDistance = lastDistanceMeters;
            const K = parseFloat(K_FACTOR);
            const Re = calculateEffectiveEarthRadius(K);
            const lambda = 299792458 / (freqMhz * 1e6); // 波長 (m)

            let propLos = true; // 経路見通し
            let minF1Margin = Infinity; // 最小フレネルゾーン余裕
            let maxF1BlockageRatio = 0; // 最大フレネルゾーン遮蔽率 (0～1.0)
            let keIndex = -1; // ナイフエッジ回折点として利用する最大遮蔽点のインデックス
            let totalMaxHeight = -Infinity;

            const txElevation = profile[0].elevation;
            const rxElevation = profile[profile.length - 1].elevation;
            const txTotalHeight = txElevation + txHeightM; // Txアンテナの絶対高
            const rxTotalHeight = rxElevation + rxHeightM; // Rxアンテナの絶対高

            // Tx/Rx方位角の計算
            const txCoord = profile[0].coord;
            const rxCoord = profile[profile.length - 1].coord;
            const txAzimuth = calculateGreatCircleBearing(txCoord, rxCoord);
            const rxAzimuth = calculateGreatCircleBearing(rxCoord, txCoord);

            for (let i = 0; i < profile.length; i++) {
                const p = profile[i];
                const d = p.distance;
                const d_rem = totalDistance - d;
                const isIntermediate = d > 0 && d < totalDistance;

                // 地球の曲率補正
                const correctionProp = (d * d_rem) / (2 * Re);
                // LOS直線上の高さ (Tx-Rxを直線で結んだ高さ + 地球曲率補正)
                const baseProp = txTotalHeight + (rxTotalHeight - txTotalHeight) * (d / totalDistance);
                const heightProp = baseProp + correctionProp;

                p.heightProp = heightProp;
                const F1 = calculateFresnelRadius(d, d_rem, lambda);
                p.F1 = F1;
                // 地形クリアランス (正: LOSラインより上, 負: LOSラインより下)
                p.clearanceProp = (p.elevation - heightProp) * -1;
                // F1ゾーン余裕 (正: F1ゾーン確保, 負: F1ゾーン遮蔽)
                p.F1Margin = p.clearanceProp - F1;

                if (isIntermediate) {
                    minF1Margin = Math.min(minF1Margin, p.F1Margin);
                    if (p.clearanceProp < 0) propLos = false; // 地形がLOSラインを遮蔽

                    // F1ゾーン遮蔽率の計算 (0%: F1ゾーン下端クリアランス確保, 100%: LOSラインで遮蔽)
                    // 遮蔽の深さ (F1 - clearanceProp) を F1 で割る
                    const currentBlockageRatio = (F1 - p.clearanceProp) / F1;

                    if (currentBlockageRatio > maxF1BlockageRatio) {
                        maxF1BlockageRatio = currentBlockageRatio;
                        keIndex = i; // 最大遮蔽点として記録
                    }
                }
                totalMaxHeight = Math.max(totalMaxHeight, p.elevation);
            }

            // 損失と電力の計算
            const freespaceLossDb = calculateFSPL(totalDistance, freqMhz);
            let additionalLossDb = 0.00;
            let modelName = '自由空間損失 (FSPL)';

            // --- 伝搬モデルの切り替えロジック (P.526 準拠) ---
            // ここではまず Deygout の厳密回折損失を試算し、それが合理的な値であれば採用します。
            // 小さな遮蔽では FSPL を維持し、非常に長距離や微小遮蔽では平滑球面近似にフォールバックします。

            const blockagePercent = maxF1BlockageRatio * 100;

            if (blockagePercent <= 5) {
                // ほぼクリア、FSPLを採用
                modelName = '自由空間損失 (FSPL)';
                additionalLossDb = 0;
            } else {
                // Deygout を用いた多峰回折評価（P.526 の主要部分の実装）
                try {
                    const diffLoss = deygoutDiffractionLoss(profile, lambda, txTotalHeight, rxTotalHeight, Re);
                    // diffLoss が異常に大きい/小さい場合はフォールバック
                    if (!isFinite(diffLoss) || diffLoss < 0 || diffLoss > 200) {
                        throw new Error('diffLoss out of bounds');
                    }
                    additionalLossDb = diffLoss;
                    modelName = `ITU-R P.526 (Deygout) Ld:${additionalLossDb.toFixed(2)} dB`;
                } catch (err) {
                    // フォールバック: 平滑球面大地など
                    additionalLossDb = calculateSmoothEarthLoss(totalDistance, freqMhz, K_FACTOR);
                    modelName = `平滑球面大地損失 (フォールバック)`;
                }
            }

            // --------------------------------------------------

            const totalLossDb = freespaceLossDb + additionalLossDb;
            const rxPowerDbm = txPowerDbm + txGainDbi + rxGainDbi - totalLossDb - txCableLossDb - rxCableLossDb;

            // 仰角/俯角の計算
            const toDegrees = (rad) => rad * 180 / Math.PI;
            const txToRxAngleRad = Math.atan2(rxTotalHeight - txTotalHeight + (totalDistance * totalDistance) / (2 * Re), totalDistance);
            const rxToTxAngleRad = Math.atan2(txTotalHeight - rxTotalHeight + (totalDistance * totalDistance) / (2 * Re), totalDistance);
            const txToRxAngleDeg = toDegrees(txToRxAngleRad);
            const rxToTxAngleDeg = toDegrees(rxToTxAngleRad) * -1; // 負の値で俯角を示す

            // グラフ描画用座標データ
            const losLineCoords = profile.map(p => [p.distance, p.heightProp]);
            const f1UpperCoords = profile.map(p => [p.distance, p.heightProp + p.F1]);
            const f1LowerCoords = profile.map(p => [p.distance, p.heightProp - p.F1]);

            return {
                distance: totalDistance, txHeight: txHeightM, rxHeight: rxHeightM, kFactor: K_FACTOR, frequencyMhz: freqMhz,
                txPowerDbm: txPowerDbm, txGainDbi: txGainDbi, rxGainDbi: rxGainDbi, txCableLossDb: txCableLossDb, rxCableLossDb: rxCableLossDb,
                rxPowerDbm: rxPowerDbm, propLos: propLos, minF1Margin: minF1Margin, totalMaxHeight: totalMaxHeight, lossType: modelName,
                txAngle: txToRxAngleDeg, rxAngle: rxToTxAngleDeg, freespaceLossDb: freespaceLossDb, txAzimuth: txAzimuth, rxAzimuth: rxAzimuth,
                totalLossDb: totalLossDb,
                losLineCoords: losLineCoords, f1UpperCoords: f1UpperCoords, f1LowerCoords: f1LowerCoords,
                profileData: profile,
                maxF1BlockageRatio: maxF1BlockageRatio,
            };
        }


        // ====================================================================
        // 【描画・表示関連】
        // ====================================================================

        /**
         * 地図上にTx/Rxの点フィーチャを追加（Tx:赤T, Rx:青R）
         */
        function addPointFeature(coord, pointType) {
            const feature = new ol.Feature({
                geometry: new ol.geom.Point(coord),
                type: pointType // 'MeasurementPointTx' or 'MeasurementPointRx'
            });
            vectorSource.addFeature(feature);
            features.push(feature);
        }

        /**
         * 伝搬計算結果をサマリーパネルに表示
         */
        function displayMeasurementResults(propResults) {
            const content = document.getElementById('content-summary');
            if (!propResults || typeof propResults.totalLossDb === 'undefined' || propResults.distance === 0) {
                content.innerHTML = `<h4>伝搬計算エラー</h4><p>計算結果が不完全または距離がゼロです。座標を確認してください。</p>`;
                document.getElementById('profile-popup').style.display = 'none';
                return;
            }
            const txLonLat = points[0];
            const rxLonLat = points[1];
            const txUtm = convertToUtm(txLonLat);
            const rxUtm = convertToUtm(rxLonLat);
            const distanceKm = propResults.distance / 1000;
            const losStatus = propResults.propLos ? `<span class="los-text">LOS (見通し確保)</span>` : `<span class="nlos-text">NLOS (遮蔽あり)</span>`;

            // F1ゾーンのクリアランス状況に基づき、F1遮蔽率を表示
            let f1StatusText;
            const blockagePercent = (propResults.maxF1BlockageRatio * 100).toFixed(1);

            if (propResults.minF1Margin > 0) {
                 f1StatusText = `<span class="los-text">F1確保 (${propResults.minF1Margin.toFixed(2)} m)</span>`;
            } else if (propResults.minF1Margin > -propResults.profileData[propResults.profileData.findIndex(p => p.F1Margin === propResults.minF1Margin)].F1) {
                 // F1ゾーン遮蔽があるが、LOSラインは遮蔽されていない
                 f1StatusText = `<span class="nlos-text">F1遮蔽 (${blockagePercent}%)</span>`;
            } else {
                 // LOSラインも遮蔽されている
                 f1StatusText = `<span class="nlos-text">LOS/F1遮蔽 (${blockagePercent}%)</span>`;
            }

            content.innerHTML = `
                <h4>計測・座標情報</h4>
                <table class="info-table" style="width: 100%;">
                    <tr><th>Tx (送信)</th><td>${txLonLat[1].toFixed(5)}, ${txLonLat[0].toFixed(5)}</td></tr>
                    <tr><td colspan="2" style="text-align: right; font-size: 0.8em; padding-top: 0; padding-bottom: 5px;">
                        MGRS: ${convertToMGRS(txLonLat, 5)}<br>
                        ${txUtm}
                    </td></tr>
                    <tr><th>Rx (受信)</th><td>${rxLonLat[1].toFixed(5)}, ${rxLonLat[0].toFixed(5)}</td></tr>
                    <tr><td colspan="2" style="text-align: right; font-size: 0.8em; padding-top: 0; padding-bottom: 5px;">
                        MGRS: ${convertToMGRS(rxLonLat, 5)}<br>
                        ${rxUtm}
                    </td></tr>
                    <tr><th>方位角</th><td>Tx→Rx: <span class="azimuth-angle">${propResults.txAzimuth.toFixed(2)}°</span></td></tr>
                    <tr><th></th><td>Rx→Tx: <span class="azimuth-angle">${propResults.rxAzimuth.toFixed(2)}°</span></td></tr>
                </table>
                <h4 style="margin-top: 10px;">伝搬結果サマリー</h4>
                <table class="info-table" style="width: 100%;">
                    <tr><th>距離 (km)</th><td>${distanceKm.toFixed(3)} km</td></tr>
                    <tr><th>経路見通し</th><td>${losStatus}</td></tr>
                    <tr><th>F1ゾーン遮蔽率</th><td>${f1StatusText}</td></tr>
                    <tr><th>仰角/俯角</th><td>Tx: <span class="elevation-angle">${propResults.txAngle.toFixed(3)}°</span> / Rx: <span class="elevation-angle">${propResults.rxAngle.toFixed(3)}°</span></td></tr>
                    <tr><th>空間損失 (dB)</th><td>${propResults.freespaceLossDb.toFixed(2)} dB</td></tr>
                    <tr><th>総損失 (dB)</th><td><strong>${propResults.totalLossDb.toFixed(2)} dB</strong> (${propResults.lossType})</td></tr>
                    <tr><th>受信電力 (dBm)</th><td><strong>${propResults.rxPowerDbm.toFixed(2)} dBm</strong></td></tr>
                </table>
            `;
        }


        /**
         * Chart.jsのリサイズロジックを実行
         */
        function executeResizeLogic() {
            if (!chartInstances.elevation || !chartInstances.levelDiagram) return;
            const elevCanvas = chartInstances.elevation.canvas;
            const levelCanvas = chartInstances.levelDiagram.canvas;
            const elevationContainer = elevCanvas.parentNode;
            const levelContainer = levelCanvas.parentNode;
            const targetElevWidth = Math.max(MIN_CHART_WIDTH, elevationContainer.clientWidth);
            const targetElevHeight = Math.max(MIN_CHART_HEIGHT, elevationContainer.clientHeight);
            const targetLevelWidth = Math.max(MIN_CHART_WIDTH, levelContainer.clientWidth);
            const targetLevelHeight = Math.max(MIN_CHART_HEIGHT, levelContainer.clientHeight);
            elevCanvas.style.width = `${targetElevWidth}px`;
            elevCanvas.style.height = `${targetElevHeight}px`;
            elevCanvas.width = targetElevWidth * PIXEL_RATIO;
            elevCanvas.height = targetElevHeight * PIXEL_RATIO;
            levelCanvas.style.width = `${targetLevelWidth}px`;
            levelCanvas.style.height = `${targetLevelHeight}px`;
            levelCanvas.width = targetLevelWidth * PIXEL_RATIO;
            levelCanvas.height = targetLevelHeight * PIXEL_RATIO;
            try {
                chartInstances.elevation.resize(targetElevWidth, targetElevHeight);
                chartInstances.levelDiagram.resize(targetLevelWidth, targetLevelHeight);
                chartInstances.elevation.update();
                chartInstances.levelDiagram.update();
            } catch (error) {
                console.error(`[RESIZE ERROR] Chart.js resize/update failed:`, error);
            }
        }

        function triggerChartResize(isInitial = false) {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                executeResizeLogic();
            }, isInitial ? 0 : 100);
        }

        function setupResizeObserver() {
            const chartsContainer = document.getElementById('profile-charts');
            if (typeof ResizeObserver === 'function' && !resizeObserver) {
                resizeObserver = new ResizeObserver(() => {
                    if (profilePopup.style.display !== 'none') {
                        triggerChartResize(false);
                    }
                });
            }
            if (resizeObserver && chartsContainer) {
                try {
                    resizeObserver.unobserve(chartsContainer);
                } catch (e) {
                    // ignore
                }
                resizeObserver.observe(chartsContainer);
            }
        }

        function stopResizeObserver() {
            const chartsContainer = document.getElementById('profile-charts');
            if (resizeObserver && chartsContainer) {
                resizeObserver.unobserve(chartsContainer);
                clearTimeout(debounceTimer);
            }
            if (chartInstances.elevation) chartInstances.elevation.stop();
            if (chartInstances.levelDiagram) chartInstances.levelDiagram.stop();
        }

                            function renderChartsInPopup(propResults, profile) {
                                const profilePopup = document.getElementById('profile-popup');
                                const statusElement = document.getElementById('profile-status-info');
                                if (!propResults || propResults.distance === 0 || !profile || profile.length < 2) {
                                    profilePopup.style.display = 'none';
                                    stopResizeObserver();
                                    return;
                                }
                                if (chartInstances.elevation) chartInstances.elevation.destroy();
                                if (chartInstances.levelDiagram) chartInstances.levelDiagram.destroy();
                                profilePopup.style.display = 'block';
                                statusElement.textContent = `距離: ${(propResults.distance / 1000).toFixed(3)} km, 周波数: ${propResults.frequencyMhz} MHz, K=${propResults.kFactor}`;

                                // --- 標高プロファイルグラフのY軸範囲設定（変更なし） ---
                                const elevations = profile.map(p => p.elevation);
                                const maxElevation = Math.max(...elevations);
                                const minElevation = Math.min(...elevations);

                                const yAxisMaxElev = maxElevation + 100;
                                const yAxisMinElev = minElevation - 10;
                                // ----------------------------------------------------

                                // 標高プロファイルグラフの描画 (省略 - Y軸設定のみ変更)
                                const elevCanvas = document.getElementById('elevation-chart');
                                const elevCtx = elevCanvas.getContext('2d');
                                chartInstances.elevation = new Chart(elevCtx, {
                                    type: 'line',
                                    data: {
                                        labels: profile.map(p => (p.distance / 1000).toFixed(2)),
                                        datasets: [
                                            { label: '地表標高 (DEM)', data: profile.map(p => ({ x: p.distance / 1000, y: p.elevation })), borderColor: 'rgb(102, 51, 0)', backgroundColor: 'rgba(102, 51, 0, 0.2)', pointRadius: 0, fill: false },
                                            { label: 'F1ゾーン下部ライン', data: propResults.f1LowerCoords.map(c => ({ x: c[0] / 1000, y: c[1] })), borderColor: 'rgb(255, 165, 0)', borderDash: [6,3], pointRadius: 0, fill: false },
                                            //{ label: 'F1ゾーン (K='+propResults.kFactor+')', data: propResults.f1UpperCoords.map(c => ({ x: c[0] / 1000, y: c[1] })), borderColor: 'transparent', b[...]
                                            { label: 'LOSライン (K='+propResults.kFactor+')', data: propResults.losLineCoords.map(c => ({ x: c[0] / 1000, y: c[1] })), borderColor: 'rgb(0, 0, 255)', borderWidth: 2, pointRadius: 0, fill: false }
                                        ]
                                    },
                                    options: {
                                        responsive: true, maintainAspectRatio: false, devicePixelRatio: PIXEL_RATIO, animation: false,
                                        scales: {
                                            x: { title: { display: true, text: '距離 (km)' }, type: 'linear', min: 0, max: propResults.distance / 1000 },
                                            y: {
                                                title: { display: true, text: '高さ (m)' },
                                                min: Math.min(yAxisMinElev, ...propResults.f1LowerCoords.map(c => c[1])),
                                                max: Math.max(yAxisMaxElev, ...propResults.f1UpperCoords.map(c => c[1]), profile[0].elevation + propResults.txHeight, profile[profile.length - 1].elevation + propResults.rxHeight),
                                                ticks: { callback: function(value) { return value + ' m'; } }
                                            }
                                        },
                                        plugins: {
                                            legend: { display: true },
                                            title: { display: true, text: '標高プロファイル (K=' + propResults.kFactor + ')' },
                                            annotation: { annotations: {
                                                txPoint: { type: 'point', xValue: 0, yValue: profile[0].elevation + propResults.txHeight, radius: 5, backgroundColor: 'red', label: { content: 'Tx', display: true } },
                                                rxPoint: { type: 'point', xValue: propResults.distance / 1000, yValue: profile[profile.length - 1].elevation + propResults.rxHeight, radius: 5, backgroundColor: 'blue', label: { content: 'Rx', display: true } },
                                            } }
                                        }
                                    }
                                });

                                // --- レベルダイヤグラムのデータポイントとY軸範囲の動的計算 ---
                                const levelDataPoints = [
                                    propResults.txPowerDbm,
                                    propResults.txPowerDbm - propResults.txCableLossDb,
                                    propResults.txPowerDbm - propResults.txCableLossDb + propResults.txGainDbi,
                                    propResults.txPowerDbm - propResults.txCableLossDb + propResults.txGainDbi - propResults.totalLossDb,
                                    propResults.txPowerDbm - propResults.txCableLossDb + propResults.txGainDbi - propResults.totalLossDb + propResults.rxGainDbi,
                                    propResults.rxPowerDbm
                                ];

                                const minLevel = Math.min(...levelDataPoints);
                                const maxLevel = Math.max(...levelDataPoints);

                                // Y軸の上下限を計算: 最小値から-5dB、最大値から+5dBをマージンとする
                                const yAxisLevelMin = Math.floor(minLevel / 10) * 10 - 10; // 10dB単位で切り捨ててマージン10dB
                                const yAxisLevelMax = Math.ceil(maxLevel / 10) * 10 + 10;  // 10dB単位で切り上げてマージン10dB

                                // レベルダイヤグラムの描画
                                const levelCanvas = document.getElementById('level-diagram-chart');
                                const levelCtx = levelCanvas.getContext('2d');
                                chartInstances.levelDiagram = new Chart(levelCtx, {
                                    type: 'line',
                                    data: {
                                        labels: ['送信出力', 'Tx Ant入力\n(ケーブルロス)', 'Tx EIRP\n(Tx利得)', 'Rx Ant入力\n(空間損失)', 'Rx Ant出力\n(Rx利得)', '受信機\n入力'],
                                        datasets: [{
                                            label: '電力レベル (dBm)',
                                            data: levelDataPoints,
                                            borderColor: 'rgb(0, 0, 255)', backgroundColor: 'rgba(0, 0, 255, 0.2)', borderWidth: 3, pointRadius: 6, fill: false, tension: 0, yAxisID: 'y'
                                        }]
                                    },
                                    options: {
                                        responsive: true, maintainAspectRatio: false, devicePixelRatio: PIXEL_RATIO, animation: false,
                                        scales: {
                                            x: { title: { display: true, text: '伝送経路の段階' }, type: 'category', grid: { display: false }, ticks: { callback: function(value, index) { return this.getLabelForValue(value); } } },
                                            y: {
                                                title: { display: true, text: '電力レベル (dBm)' },
                                                min: yAxisLevelMin, // 【修正箇所】動的な最小値を適用
                                                max: yAxisLevelMax, // 【修正箇所】動的な最大値を適用
                                                ticks: { callback: function(value) { return value.toFixed(2) + ' dBm'; } }
                                            }
                                        },
                                        plugins: { legend: { display: false }, title: { display: true, text: 'レベルダイヤグラム (折れ線グラフ)' }, tooltip: { callbacks: { label: function(context) { return context.parsed.y.toFixed(2) + ' dBm'; } } }
                                        }
                                    }
                                });
                                setupResizeObserver();
                                setTimeout(() => { triggerChartResize(true); }, 50);
                            }

        /**
         * 標高データ取得と伝搬計算のメインプロセス
         */
        async function processMeasurement() {
            if (points.length !== 2) return;
            //vectorSource.clear(); features = []; // マーカーを一旦クリア
            try {
                // 1. 標高プロファイルの取得
                const profile = await getElevationProfile(points[0], points[1]);

                // 2. 設定値の取得 (getSetting関数を使用)
                const K_FACTOR = getSetting('k-factor', 1.333);
                const freqMhz = getSetting('freq-mhz', 1000);
                const txHeightM = getSetting('tx-height-m', 30);
                const rxHeightM = getSetting('rx-height-m', 30);
                const txPowerDbm = getSetting('tx-power-dbm', 30);
                const txGainDbi = getSetting('tx-gain-dbi', 15);
                const rxGainDbi = getSetting('rx-gain-dbi', 15);
                const txCableLossDb = getSetting('tx-cable-loss-db', 1.5);
                const rxCableLossDb = getSetting('rx-cable-loss-db', 1.5);

                // 3. 伝搬特性の計算
                const propResults = calculatePropagation(profile, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb);

                // 4. 結果の表示とマーカーの再描画
                if (propResults) {
                    displayMeasurementResults(propResults);
                    renderChartsInPopup(propResults, profile);
                    const txWebMercator = ol.proj.fromLonLat(points[0]);
                    const rxWebMercator = ol.proj.fromLonLat(points[1]);
                    addPointFeature(txWebMercator, 'MeasurementPointTx');
                    addPointFeature(rxWebMercator, 'MeasurementPointRx');
                } else {
                    displayMeasurementResults(null);
                }
            } catch (e) {
                console.error("測定処理中に予期せぬエラーが発生:", e);
                document.getElementById('content-summary').innerHTML = `<h4>致命的なエラー</h4><p>伝搬計算の実行中にエラーが発生しました。</p>`;
                document.getElementById('profile-popup').style.display = 'none';
                stopResizeObserver();
            }
        }

        /**
         * 測定状態をリセット (地図上のマーカーとポップアップをクリア)
         */
        function resetMeasurement() {
            const profilePopup = document.getElementById('profile-popup');
            points = []; // 座標をリセット
            vectorSource.clear(); profileVectorSource.clear(); features = [];
            stopResizeObserver();
            profilePopup.style.display = 'none';
            if (chartInstances.elevation) chartInstances.elevation.destroy();
            if (chartInstances.levelDiagram) chartInstances.levelDiagram.destroy();
            document.getElementById('content-summary').innerHTML = `<h4>計測・座標情報</h4><p>Tx点（1点目）を**クリック**してください。</p>`;
            document.getElementById('profile-status-info').textContent = 'データ待機中...';
            profileData = null; elevationCache.clear(); lastDistanceMeters = 0;
        }

        /**
         * 設定値に基づき計算を再実行
         */
        function executeRecalculation() {
            if (points.length === 2 && profileData && lastDistanceMeters > 0) {
                // 標高プロファイルが既にある場合は再計算のみ
                profileVectorSource.clear();
                for (const p of profileData) {
                    const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(p.webMercatorCoord), type: 'ProfilePoint' });
                    profileVectorSource.addFeature(pointFeature);
                }

                // 設定値を取得し、伝搬特性を再計算
                const K_FACTOR = getSetting('k-factor', 1.333);
                const freqMhz = getSetting('freq-mhz', 1000);
                const txHeightM = getSetting('tx-height-m', 30);
                const rxHeightM = getSetting('rx-height-m', 30);
                const txPowerDbm = getSetting('tx-power-dbm', 30);
                const txGainDbi = getSetting('tx-gain-dbi', 15);
                const rxGainDbi = getSetting('rx-gain-dbi', 15);
                const txCableLossDb = getSetting('tx-cable-loss-db', 1.5);
                const rxCableLossDb = getSetting('rx-cable-loss-db', 1.5);

                const propResults = calculatePropagation(profileData, txHeightM, rxHeightM, K_FACTOR, freqMhz, txPowerDbm, txGainDbi, rxGainDbi, txCableLossDb, rxCableLossDb);
                if (propResults) {
                    displayMeasurementResults(propResults);
                    renderChartsInPopup(propResults, profileData);
                } else {
                    displayMeasurementResults(null);
                }
            } else if (points.length === 2) {
                // 座標は設定されているがプロファイルデータがない場合 (起動直後など)
                processMeasurement();
            } else {
                alert("Tx点とRx点が設定されていません。地図をクリックして2点を指定してください。");
            }
        }


        // ====================================================================
        // 【OpenLayers初期化とイベント設定】
        // ====================================================================

        let map;
        const profileCloser = document.getElementById('profile-closer');
        const profilePopup = document.getElementById('profile-popup');
        const profileHeader = document.querySelector('#profile-popup > .result-window-header');

        // ベースレイヤーの定義
        const gsiStdLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', attributions: '地理院タイル' }), visible: true });
        const gsiPhotoLayer = new ol.layer.Tile({ source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', attributions: '地理院タイル (写真)' }), visible: false });
        const osmLayer = new ol.layer.Tile({ source: new ol.source.OSM(), visible: false });
        const baseLayerGroup = new ol.layer.Group({ layers: [gsiStdLayer, gsiPhotoLayer, osmLayer] });

        // プロファイル点レイヤー
        const profileVectorSource = new ol.source.Vector();
        const profileVectorLayer = new ol.layer.Vector({
            source: profileVectorSource,
