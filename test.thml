<!DOCTYPE html>
<html>
<head>
    <title>OpenLayers çµ±åˆè¨ˆæ¸¬ãƒ»ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—å€‹åˆ¥ãƒ‰ãƒ©ãƒƒã‚°å¯¾å¿œ</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
    <style>
        #map {
            width: 100%;
            height: 900px;
        }
        /* è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .ol-popup {
            position: absolute; background-color: white; padding: 0; border-radius: 5px;
            border: 1px solid #cccccc; bottom: 12px; left: -50px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-width: 200px; z-index: 100;
        }
        #popup-header {
            cursor: move; background-color: #f0f0f0; padding: 5px 15px; border-bottom: 1px solid #ccc;
            font-weight: bold;
        }
        #popup-content { padding: 15px; }
        .ol-popup-closer { text-decoration: none; position: absolute; top: 5px; right: 8px; z-index: 10; }
        .ol-popup-closer:after { content: "âœ–"; }

        /* æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #profile-popup {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #1f77b4;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            min-width: 400px;
            min-height: 200px;
            position: absolute;
            z-index: 99;

            box-sizing: border-box;
            resize: both;
            overflow: auto;
            max-height: 80vh;

            display: flex;
            flex-direction: column;
        }
        #profile-popup-header {
            font-weight: bold;
            margin-bottom: 5px;
            cursor: move;
            background-color: #e6f2ff;
            padding: 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #profile-closer {
            position: absolute;
            top: 5px;
            right: 8px;
            text-decoration: none;
            font-weight: bold;
            color: #333;
        }

        #profile-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }

        /* Chart.js ã®ã‚³ãƒ³ãƒ†ãƒŠã‚¹ã‚¿ã‚¤ãƒ« */
        #elevationChart {
            width: 100% !important;
            flex-grow: 1;
            min-height: 100px;
        }
        #profile-status {
            flex-shrink: 0;
            padding-top: 5px;
        }

        /* ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #layer-switcher {
            position: absolute; top: 10px; left: 10px; background: white; padding: 10px;
            border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); z-index: 1000;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <div id="profile-popup">
        <div id="profile-popup-header">æ¨™é«˜æ–­é¢å›³</div>
        <a href="#" id="profile-closer">âœ–</a>
        <div id="profile-content">
            <canvas id="elevationChart"></canvas>
            <div id="profile-status" style="font-size: 0.9em; margin-top: 5px;"></div>
        </div>
    </div>

    <div id="popup" class="ol-popup">
        <div id="popup-header">è¨ˆæ¸¬çµæœ</div>
        <a href="#" id="popup-closer" class="ol-popup-closer"></a>
        <div id="popup-content"></div>
    </div>

    <div id="layer-switcher">
        <div>ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="base_type" value="std" checked> æ¨™æº–ï¼ˆåœ°å›³ï¼‰</label><br>
        <label><input type="radio" name="base_type" value="photo"> å†™çœŸï¼ˆåœ°ç†é™¢ï¼‰</label><hr>
        <div>ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="tile_source" value="osm" checked> OpenStreetMap</label><br>
        <label><input type="radio" name="tile_source" value="gsi"> å›½åœŸåœ°ç†é™¢ï¼ˆæ¨™æº–ï¼‰</label>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // --- 1. ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾© ---
        const osmLayer = new ol.layer.Tile({ title: 'OpenStreetMap', type: 'base', visible: true, source: new ol.source.OSM() });
        const gsiStdLayer = new ol.layer.Tile({ title: 'GSI_Standard', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' }) });
        const gsiPhotoLayer = new ol.layer.Tile({ title: 'GSI_Photo', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' }) });
        const baseLayerGroup = new ol.layer.Group({ layers: [osmLayer, gsiStdLayer, gsiPhotoLayer] });

        // --- 2. 2ç‚¹é–“è¨ˆæ¸¬ç”¨å¤‰æ•°ã¨ãƒãƒ¼ã‚«ãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ ---
        let points = [];
        const vectorSource = new ol.source.Vector();
        const lineStyle = new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 255, 0.7)', width: 4, lineDash: [10, 5] }) });
        const maxElevStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({color: 'orange'}), stroke: new ol.style.Stroke({color: 'black', width: 3}) }) });
        const pointStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({color: 'red'}), stroke: new ol.style.Stroke({color: 'white', width: 2}) }) });

        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.get('type') === 'max_elevation') { return maxElevStyle; }
                else if (feature.getGeometry().getType() === 'LineString') { return lineStyle; }
                else { return pointStyle; }
            }
        });

        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®è¨­å®š
        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');
        const popupHeader = document.getElementById('popup-header');
        const overlay = new ol.Overlay({ element: container, autoPan: true, autoPanAnimation: { duration: 250 } });

        // æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®è¨­å®š
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');
        const profileHeader = document.getElementById('profile-popup-header');

        const profileOverlay = new ol.Overlay({
            element: profileContainer,
            autoPan: false,
            positioning: 'bottom-center'
        });
        profileOverlay.setPosition(undefined);

        closer.onclick = function() {
            overlay.setPosition(undefined); closer.blur(); vectorSource.clear(); points = [];
            if (elevationChart) elevationChart.destroy();
            profileOverlay.setPosition(undefined);
            return false;
        };
        profileCloser.onclick = function() {
            profileOverlay.setPosition(undefined);
            return false;
        };


        // --- 3. ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ã¨ãƒªã‚µã‚¤ã‚ºå®‰å®šåŒ– (ä¿®æ­£æ¸ˆã¿) ---
        let isDragging = false;
        let startPixel;
        let startCoord;
        let currentDraggingOverlay = null; // ğŸŒŸ ç¾åœ¨ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¿½è·¡

        // å…±é€šã®ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹å‡¦ç†
        function startDrag(event, targetOverlay) {
            // ãƒªã‚µã‚¤ã‚ºæ“ä½œä¸­ã¯ãƒ‰ãƒ©ãƒƒã‚°ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹
            const style = window.getComputedStyle(profileContainer);
            if (style.cursor === 'nwse-resize' || style.cursor === 'se-resize') {
                 return;
            }

            if (targetOverlay.getPosition()) {
                isDragging = true;
                startPixel = map.getEventPixel(event);
                startCoord = targetOverlay.getPosition();
                currentDraggingOverlay = targetOverlay; // ğŸŒŸ ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ã‚’è¨˜éŒ²
                map.getInteractions().forEach(function(interaction) { interaction.setActive(false); });
            }
        }

        // è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒ‰ãƒ©ãƒƒã‚°
        popupHeader.addEventListener('mousedown', function(event) {
            startDrag(event, overlay);
        });

        // æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒ‰ãƒ©ãƒƒã‚°
        profileHeader.addEventListener('mousedown', function(event) {
            startDrag(event, profileOverlay);
        });

        // å…±é€šã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•ãƒ»çµ‚äº†å‡¦ç†
        document.addEventListener('mousemove', function(event) {
            if (!isDragging || !currentDraggingOverlay) return; // ğŸŒŸ ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ãŒãªã‘ã‚Œã°æŠœã‘ã‚‹

            const currentPixel = map.getEventPixel(event);
            const deltaPixelX = currentPixel[0] - startPixel[0];
            const deltaPixelY = currentPixel[1] - startPixel[1];

            const newCoordPixel = map.getPixelFromCoordinate(startCoord);
            const newCoord = map.getCoordinateFromPixel([ newCoordPixel[0] + deltaPixelX, newCoordPixel[1] + deltaPixelY ]);
            currentDraggingOverlay.setPosition(newCoord); // ğŸŒŸ è¨˜éŒ²ã•ã‚ŒãŸã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ç§»å‹•
        });
        document.addEventListener('mouseup', function() {
            if (isDragging) {
                isDragging = false;
                currentDraggingOverlay = null; // ğŸŒŸ ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†æ™‚ã«ãƒªã‚»ãƒƒãƒˆ
                map.getInteractions().forEach(function(interaction) { interaction.setActive(true); });
            }
        });

        // ãƒ‡ãƒã‚¦ãƒ³ã‚¹é–¢æ•°ã®å®šç¾© (å®‰å®šåŒ–ã®ãŸã‚)
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // ãƒªã‚µã‚¤ã‚ºå¾Œã® Chart.js ã®å†æç”»ï¼ˆãƒ‡ãƒã‚¦ãƒ³ã‚¹é©ç”¨ï¼‰
        const debouncedChartResize = debounce(() => {
            if (elevationChart) {
                elevationChart.resize();
            }
        }, 50);

        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                if (entry.target.id === 'profile-popup') {
                    debouncedChartResize();
                }
            }
        });
        resizeObserver.observe(profileContainer);


        // --- 4. åœ°å›³ã®åˆæœŸåŒ– ---
        const map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, vectorLayer],
            overlays: [overlay, profileOverlay],
            view: new ol.View({
                center: ol.proj.fromLonLat([139.75, 35.68]),
                zoom: 12,
                maxZoom: 18
            })
        });


        // --- 5. ã‚¿ã‚¤ãƒ«åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½ (çœç•¥) ---
        function hideAllBaseLayers() { baseLayerGroup.getLayers().forEach(layer => { layer.setVisible(false); }); }
        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') {
                const baseType = document.querySelector('input[name="base_type"]:checked').value;
                const tileSource = document.querySelector('input[name="tile_source"]:checked').value;
                hideAllBaseLayers();
                if (baseType === 'std') {
                    if (tileSource === 'osm') { osmLayer.setVisible(true); } else if (tileSource === 'gsi') { gsiStdLayer.setVisible(true); }
                } else if (baseType === 'photo') { gsiPhotoLayer.setVisible(true); }
            }
        });


        // --- 6. æ¨™é«˜æ–­é¢å›³ï¼ˆChart.jsï¼‰é–¢é€£é–¢æ•° ---
        let elevationChart = null;

        function drawElevationChart(profile, distanceMeters) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            const labels = profile.map((_, index) => {
                const fraction = index / (profile.length - 1);
                const dist = distanceMeters * fraction;
                return (dist / 1000).toFixed(2);
            });
            const elevations = profile.map(p => p.elevation);

            if (elevationChart) { elevationChart.destroy(); }

            elevationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'æ¨™é«˜ (m)',
                        data: elevations,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km` } },
                        y: { title: { display: true, text: 'æ¨™é«˜ (m)' }, beginAtZero: false }
                    },
                    plugins: { legend: { display: false }, title: { display: false } }
                }
            });
            profileStatus.textContent = `è¨ˆæ¸¬å®Œäº†ã€‚å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km`;
        }

        // æ¨™é«˜å–å¾—é–¢æ•° (çœç•¥)
        async function getElevation(coordinate) {
            const [lon, lat] = coordinate;
            const url = `https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php?lat=${lat}&lon=${lon}&outtype=json`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.elevation !== 'å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ' ? parseFloat(data.elevation) : null;
            } catch (error) {
                console.error("æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:", error);
                return null;
            }
        }

        // ç·šå½¢è£œé–“é–¢æ•° (çœç•¥)
        function interpolateCoordinates(coordA, coordB, fraction) {
            const lon = coordA[0] + (coordB[0] - coordA[0]) * fraction;
            const lat = coordA[1] + (coordB[1] - coordA[1]) * fraction;
            return [lon, lat];
        }

        // 2ç‚¹é–“ã®æ¨™é«˜ã‚’è¤‡æ•°åœ°ç‚¹ã§å–å¾—ã™ã‚‹é–¢æ•° (çœç•¥)
        async function getElevationProfile(coord1, coord2, steps = 30) {
            const profile = [];
            for (let i = 0; i <= steps; i++) {
                const fraction = i / steps;
                const intermediateCoord = interpolateCoordinates(coord1, coord2, fraction);
                const elevation = await getElevation(intermediateCoord);

                profile.push({
                    coord: intermediateCoord,
                    webMercatorCoord: ol.proj.fromLonLat(intermediateCoord),
                    elevation: elevation
                });
            }
            return profile;
        }

        // --- 7. ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆ2ç‚¹é–“è¨ˆæ¸¬ï¼‰ ---
        map.on('click', async function(evt) {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);

            overlay.setPosition(undefined);

            if (points.length >= 2) {
                points = [];
                vectorSource.clear();
                profileOverlay.setPosition(undefined);
                profileStatus.textContent = '2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...';
            }

            const pointFeature = new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord) });
            vectorSource.addFeature(pointFeature);
            points.push(lonLatCoord);

            if (points.length === 2) {
                profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
                const [coord1, coord2] = points;

                // ç·šã®è¿½åŠ 
                const lineFeature = new ol.Feature({
                    geometry: new ol.geom.LineString([ ol.proj.fromLonLat(coord1), ol.proj.fromLonLat(coord2) ])
                });
                vectorSource.addFeature(lineFeature);

                // æ¨™é«˜ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ã®å–å¾—ã¨æœ€é«˜åœ°ç‚¹ã®ç‰¹å®š
                const profile = await getElevationProfile(coord1, coord2, 30);
                let maxElevation = -Infinity;
                let maxElevationPoint = null;
                profile.forEach(p => { if (p.elevation !== null && p.elevation > maxElevation) { maxElevation = p.elevation; maxElevationPoint = p; } });

                // æœ€é«˜åœ°ç‚¹ã®ãƒãƒ¼ã‚­ãƒ³ã‚°
                if (maxElevationPoint) {
                    const maxElevFeature = new ol.Feature({
                        geometry: new ol.geom.Point(maxElevationPoint.webMercatorCoord),
                        type: 'max_elevation'
                    });
                    vectorSource.addFeature(maxElevFeature);
                }

                // è·é›¢ã®è¨ˆç®—ã¨è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®è¡¨ç¤º
                const distanceMeters = ol.sphere.getDistance(coord1, coord2);
                const htmlContent = `
                    <p><strong>å§‹ç‚¹:</strong> æ¨™é«˜: ${profile[0].elevation !== null ? profile[0].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                    <p><strong>çµ‚ç‚¹:</strong> æ¨™é«˜: ${profile[profile.length - 1].elevation !== null ? profile[profile.length - 1].elevation.toFixed(1) + ' m' : 'N/A'}</p>
                    <p><strong>æœ€é«˜æ¨™é«˜:</strong> <strong style="color: orange;">${maxElevationPoint ? maxElevationPoint.elevation.toFixed(1) + ' m' : 'N/A'}</strong></p>
                    <hr>
                    <p><strong>2ç‚¹é–“è·é›¢:</strong> <strong style="color: blue;">${(distanceMeters / 1000).toFixed(3)} km (${distanceMeters.toFixed(0)} m)</strong></p>
                `;
                content.innerHTML = htmlContent;

                // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’2ç‚¹é–“ã®ä¸­é–“ä½ç½®ã«è¡¨ç¤º
                const features = vectorSource.getFeatures();
                const centerCoord = [
                    (features[0].getGeometry().getCoordinates()[0] + features[1].getGeometry().getCoordinates()[0]) / 2,
                    (features[0].getGeometry().getCoordinates()[1] + features[1].getGeometry().getCoordinates()[1]) / 2
                ];

                overlay.setPosition(centerCoord);

                // æ–­é¢å›³ã®æç”»ã¨è¡¨ç¤º
                drawElevationChart(profile, distanceMeters);
                profileOverlay.setPosition(centerCoord);
            } else {
                 profileStatus.textContent = '2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’å®Œäº†ã—ã¦ãã ã•ã„ã€‚';
            }
        });
    </script>
</body>
</html>
