<!DOCTYPE html>
<html lang="ja">
<head>
    <title>OpenLayers çµ±åˆè¨ˆæ¸¬ãƒ»ä¼æ¬è¨ˆç®—ï¼ˆãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤/å³å´é…ç½®ï¼‰</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css">
    <style>
        /* å¿…é ˆï¼šåœ°å›³ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’å®šç¾© */
        #map {
            width: 100%;
            height: 100vh; /* åœ°å›³ã‚’ç”»é¢å…¨ä½“ã«è¡¨ç¤º */
        }

        /* --- ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—/ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«å…±é€šã‚¹ã‚¿ã‚¤ãƒ« --- */
        .control-panel, .ol-popup-draggable {
            position: absolute;
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            right: 10px; /* å³å¯„ã› */
            left: auto;
        }
        .ol-popup-draggable {
            resize: both;
            overflow: auto;
            min-width: 250px;
            min-height: 100px;
            box-sizing: border-box;
        }

        /* ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆ - åœ°å›³ã®å³ä¸Šã«é…ç½® */
        #layer-switcher {
            top: 10px;
            z-index: 1001;
        }

        /* ä¼æ¬è¨ˆç®—ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« - ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆã®ä¸‹ã«é…ç½® (é‡ãªã‚Šè§£æ¶ˆæ¸ˆã¿) */
        #propagation-controls {
            top: 160px; /* layer-switcher (ç´„130px) ã®ç›´ä¸‹ã«é…ç½® */
            max-width: 250px;
            z-index: 1001;
        }
        #propagation-controls input[type="number"], #propagation-controls button {
            width: 80px;
            margin-left: 5px;
            margin-bottom: 5px;
        }
        #propagation-controls button {
            width: 100%;
            margin-left: 0;
        }
        #propagation-controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #propagation-controls hr {
            margin: 8px 0;
        }

        /* è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
        .ol-popup {
            top: 550px; /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®ä¸‹ã«é…ç½® */
            padding: 0;
            z-index: 100;
        }
        #popup {
            position: absolute;
        }
        #popup-header {
            cursor: move;
            background-color: #f0f0f0;
            padding: 5px 15px;
            border-bottom: 1px solid #ccc;
            font-weight: bold;
            flex-shrink: 0;
        }
        #popup-content {
            padding: 15px;
            font-size: 0.95em;
        }
        .ol-popup-closer {
            text-decoration: none;
            position: absolute;
            top: 5px;
            right: 8px;
            z-index: 10;
        }
        .ol-popup-closer:after {
            content: "âœ–";
        }

        /* æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— (å³å´ã§ä»»æ„ã®ä½ç½®ã«é…ç½®) */
        #profile-popup {
            position: absolute;
            top: 10px;
            right: 300px; /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã¨é‡ãªã‚‰ãªã„ã‚ˆã†ã«èª¿æ•´ */
            left: auto;
            min-height: 250px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 10px;
            z-index: 99;
        }
        #profile-popup-header {
            font-weight: bold;
            margin-bottom: 5px;
            cursor: move;
            background-color: #e6f2ff;
            padding: 5px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        #profile-closer {
            position: absolute;
            top: 5px;
            right: 8px;
            text-decoration: none;
            font-weight: bold;
            color: #333;
        }
        #profile-content {
            padding-top: 5px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            min-height: 0;
        }
        #elevationChart {
            width: 100% !important;
            flex-grow: 1;
            min-height: 100px;
            margin-bottom: 10px;
        }
        #powerChart {
            width: 100% !important;
            flex-grow: 0;
            min-height: 100px;
            max-height: 150px;
        }
        #profile-status {
            flex-shrink: 0;
            padding-top: 5px;
            font-size: 0.9em;
        }

        /* ãã®ä»–ã‚¹ã‚¿ã‚¤ãƒ« */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .ol-popup.top-zindex, #profile-popup.top-zindex {
            z-index: 1000 !important;
        }
        .los-yes { color: green; font-weight: bold; }
        .los-no { color: red; font-weight: bold; }
        .coord-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }
        .coord-table th, .coord-table td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: left;
        }
        .coord-table th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <div id="profile-popup" class="ol-popup-draggable" role="dialog" aria-label="æ¨™é«˜æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="profile-popup-header" tabindex="0" aria-label="æ¨™é«˜æ–­é¢å›³ãƒ˜ãƒƒãƒ€ãƒ¼">æ¨™é«˜æ–­é¢å›³ / ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ </div>
        <a href="#" id="profile-closer" aria-label="æ–­é¢å›³ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0">âœ–</a>
        <div id="profile-content">
            <canvas id="elevationChart" aria-label="æ¨™é«˜æ–­é¢å›³"></canvas>
            <canvas id="powerChart" aria-label="ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ ï¼ˆé›»åŠ›ãƒ¬ãƒ™ãƒ«ï¼‰"></canvas>
            <div id="profile-status" aria-live="polite">2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...</div>
        </div>
    </div>

    <div id="popup" class="ol-popup ol-popup-draggable" role="dialog" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—">
        <div id="popup-header" tabindex="0" aria-label="è¨ˆæ¸¬çµæœãƒ˜ãƒƒãƒ€ãƒ¼">è¨ˆæ¸¬çµæœã¨ä¼æ¬è¨ˆç®—</div>
        <a href="#" id="popup-closer" class="ol-popup-closer" aria-label="è¨ˆæ¸¬çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’é–‰ã˜ã‚‹" tabindex="0"></a>
        <div id="popup-content" aria-live="polite"></div>
    </div>

    <div id="layer-switcher" class="control-panel">
        <div>ãƒ™ãƒ¼ã‚¹ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="base_type" value="std" checked><span> æ¨™æº–ï¼ˆåœ°å›³ï¼‰</span></label><br>
        <label><input type="radio" name="base_type" value="photo"><span> å†™çœŸï¼ˆåœ°ç†é™¢ï¼‰</span></label><hr>
        <div>ã‚¿ã‚¤ãƒ«ã‚½ãƒ¼ã‚¹åˆ‡ã‚Šæ›¿ãˆ</div>
        <label><input type="radio" name="tile_source" value="osm" checked><span> OpenStreetMap</span></label><br>
        <label><input type="radio" name="tile_source" value="gsi"><span> å›½åœŸåœ°ç†é™¢ï¼ˆæ¨™æº–ï¼‰</span></label>
    </div>

    <div id="propagation-controls" class="control-panel">
        <h4>å…±é€šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            å‘¨æ³¢æ•° (MHz):
            <input type="number" id="freq-input" value="300" min="1" step="0.1">
        </label>
        <hr>
        <h4>é€ä¿¡å´ (Tx) ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            Tx ç©ºä¸­ç·šé«˜ (m):
            <input type="number" id="tx-height-input" value="10" min="0" step="0.1">
        </label>
        <label>
            é€ä¿¡å‡ºåŠ› (W):
            <input type="number" id="tx-power-input" value="10" min="0.001" step="0.1">
        </label>
        <label>
            ç©ºä¸­ç·šåˆ©å¾— (dBi):
            <input type="number" id="tx-gain-input" value="10" step="0.1">
        </label>
        <label>
            ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹ (dB):
            <input type="number" id="tx-loss-input" value="4" min="0" step="0.1">
        </label>
        <hr>
        <h4>å—ä¿¡å´ (Rx) ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</h4>
        <label>
            Rx ç©ºä¸­ç·šé«˜ (m):
            <input type="number" id="rx-height-input" value="10" min="0" step="0.1">
        </label>
        <label>
            ç©ºä¸­ç·šåˆ©å¾— (dBi):
            <input type="number" id="rx-gain-input" value="10" step="0.1">
        </label>
        <label>
            ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹ (dB):
            <input type="number" id="rx-loss-input" value="4" min="0" step="0.1">
        </label>
        <hr>
        <button id="simple-recalculate-btn">ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ã§è¨ˆç®—</button>
        <button id="itu-calculate-btn" style="margin-top: 5px;">ITU-R è¨ˆç®—å®Ÿè¡Œ (P.1546/P.1812)</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mgrs@1.0.0/dist/mgrs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // å®šæ•°å®šç¾©
        const ELEVATION_API_URL = 'https://cyberjapandata2.gsi.go.jp/general/dem/scripts/getelevation.php';
        const DEFAULT_PROFILE_STEPS = 50;
        const API_TIMEOUT_MS = 5000;
        const PROJ_WGS84 = "EPSG:4326";
        const K_FACTOR = 4 / 3;
        const EARTH_RADIUS_M = 6371000;

        // åˆæœŸå€¤å®šæ•° (ãƒªã‚»ãƒƒãƒˆç”¨)
        const INITIAL_PARAMS = {
            freq: 300,
            txHeight: 10, rxHeight: 10,
            txPower: 10,
            txGain: 10, rxGain: 10,
            txLoss: 4, rxLoss: 4
        };

        // å˜ä½å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼
        const W_TO_DBM = (W) => 10 * Math.log10(W * 1000);
        const elevationCache = new Map();

        // UTM/MGRSå¤‰æ›é–¢æ•°
        function getUtmProjDef(lon) {
            const zoneNum = Math.floor((lon + 180) / 6) % 60 + 1;
            const north = (lon >= 0) ? 'north' : 'south';
            const projString = `+proj=utm +zone=${zoneNum} +${north} +ellps=WGS84 +datum=WGS84 +units=m +no_defs`;
            if (!proj4.defs(`EPSG:${zoneNum}${north.charAt(0).toUpperCase()}`, projString)) {
                proj4.defs(`EPSG:${zoneNum}${north.charAt(0).toUpperCase()}`, projString);
            }
            return `EPSG:${zoneNum}${north.charAt(0).toUpperCase()}`;
        }
        function convertToUTM(lonLat) {
             try {
                const projCode = getUtmProjDef(lonLat[0]);
                const utmCoord = proj4(PROJ_WGS84, projCode, lonLat);
                return `${utmCoord[0].toFixed(2)}m E, ${utmCoord[1].toFixed(2)}m N (${projCode.split(':')[1]})`;
            } catch (e) {
                return "N/A (UTM error)";
            }
        }
        function convertToMGRS(lonLat, precision = 3) {
             try {
                return mgrs.forward(lonLat, precision);
            } catch (e) {
                return "N/A (MGRS error)";
            }
        }

        // ãƒ¬ã‚¤ãƒ¤ãƒ¼å®šç¾©
        const osmLayer = new ol.layer.Tile({ title: 'OpenStreetMap', type: 'base', visible: true, source: new ol.source.OSM() });
        const gsiStdLayer = new ol.layer.Tile({ title: 'GSI_Standard', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' }) });
        const gsiPhotoLayer = new ol.layer.Tile({ title: 'GSI_Photo', type: 'base', visible: false, source: new ol.source.XYZ({ url: 'https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', attributions: '<a href="https://maps.gsi.go.jp/development/ichiran.html" target="_blank">åœ°ç†é™¢ã‚¿ã‚¤ãƒ«</a>' }) });
        const baseLayerGroup = new ol.layer.Group({ layers: [osmLayer, gsiStdLayer, gsiPhotoLayer] });

        let points = [];

        const vectorSource = new ol.source.Vector();
        const lineStyle = new ol.style.Style({ stroke: new ol.style.Stroke({ color: 'rgba(0, 0, 255, 0.7)', width: 4, lineDash: [10, 5] }) });
        const maxElevStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 10, fill: new ol.style.Fill({ color: 'orange' }), stroke: new ol.style.Stroke({ color: 'black', width: 3 }) }) });
        const pointStyle = new ol.style.Style({ image: new ol.style.Circle({ radius: 7, fill: new ol.style.Fill({ color: 'red' }), stroke: new ol.style.Stroke({ color: 'white', width: 2 }) }) });
        const vectorLayer = new ol.layer.Vector({
            source: vectorSource,
            style: function(feature) {
                if (feature.get('type') === 'max_elevation') return maxElevStyle;
                if (feature.getGeometry().getType() === 'LineString') return lineStyle;
                return pointStyle;
            }
        });

        // OLè¦ç´ ã¨DOMè¦ç´ ã®é–¢é€£ä»˜ã‘
        const container = document.getElementById('popup');
        const content = document.getElementById('popup-content');
        const closer = document.getElementById('popup-closer');
        const popupHeader = document.getElementById('popup-header');
        const overlay = new ol.Overlay({ element: container, autoPan: true, autoPanAnimation: { duration: 250 } });
        const profileContainer = document.getElementById('profile-popup');
        const profileCloser = document.getElementById('profile-closer');
        const profileStatus = document.getElementById('profile-status');
        const profileHeader = document.getElementById('profile-popup-header');

        // åœ°å›³ã®åˆæœŸåŒ–
        const map = new ol.Map({
            target: 'map',
            layers: [baseLayerGroup, vectorLayer],
            overlays: [overlay],
            view: new ol.View({
                center: ol.proj.fromLonLat([139.75, 35.68]),
                zoom: 12,
                maxZoom: 18
            })
        });

        let elevationChart = null;
        let powerChart = null;

        // --- ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ (DOMæ“ä½œ) ---
        let isDragging = false;
        let startPoint;
        let startPosition;
        let currentDraggingElement = null;

        function startDrag(event, targetElement) {
            const validHeader = event.target.closest('#popup-header') || event.target.closest('#profile-popup-header');
            if (!validHeader) return;
            const isTouchEvent = event.type.includes('touch');
            if (!isTouchEvent && event.button !== 0) return;

            event.preventDefault();
            event.stopPropagation();

            const style = window.getComputedStyle(targetElement);
            if (style.cursor.includes('resize')) return;

            isDragging = true;
            currentDraggingElement = targetElement;
            currentDraggingElement.classList.add('top-zindex');

            const eventPoint = isTouchEvent ? [event.touches[0].clientX, event.touches[0].clientY] : [event.clientX, event.clientY];
            startPoint = eventPoint;

            const rect = targetElement.getBoundingClientRect();
            targetElement.style.right = 'auto';
            targetElement.style.left = `${rect.left}px`;
            startPosition = [rect.left, parseFloat(window.getComputedStyle(targetElement).top)];

            map.getInteractions().forEach(interaction => interaction.setActive(false));
        }

        function handleDragMove(event) {
            if (!isDragging || !currentDraggingElement) return;
            const isTouchEvent = event.type.includes('touch');
            if (isTouchEvent) event.preventDefault();

            const currentPoint = isTouchEvent ? [event.touches[0].clientX, event.touches[0].clientY] : [event.clientX, event.clientY];
            const deltaX = currentPoint[0] - startPoint[0];
            const deltaY = currentPoint[1] - startPoint[1];

            const newLeft = startPosition[0] + deltaX;
            const newTop = startPosition[1] + deltaY;

            const mapContainer = map.getTargetElement();
            const mapRect = mapContainer.getBoundingClientRect();
            const elWidth = currentDraggingElement.offsetWidth;
            const elHeight = currentDraggingElement.offsetHeight;

            const finalLeft = Math.max(0, Math.min(newLeft, mapRect.width - elWidth));
            const finalTop = Math.max(0, Math.min(newTop, mapRect.height - elHeight));

            currentDraggingElement.style.left = `${finalLeft}px`;
            currentDraggingElement.style.top = `${finalTop}px`;
        }

        function stopDrag() {
            if (isDragging) {
                if (currentDraggingElement) {
                    currentDraggingElement.classList.remove('top-zindex');
                }
                isDragging = false;
                currentDraggingElement = null;
                map.getInteractions().forEach(interaction => interaction.setActive(true));
            }
        }
        // --- /ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ ---

        // å…±é€šé–¢æ•°

        function resetParameters() {
            document.getElementById('freq-input').value = INITIAL_PARAMS.freq;
            document.getElementById('tx-height-input').value = INITIAL_PARAMS.txHeight;
            document.getElementById('rx-height-input').value = INITIAL_PARAMS.rxHeight;
            document.getElementById('tx-power-input').value = INITIAL_PARAMS.txPower;
            document.getElementById('tx-gain-input').value = INITIAL_PARAMS.txGain;
            document.getElementById('rx-gain-input').value = INITIAL_PARAMS.rxGain;
            document.getElementById('tx-loss-input').value = INITIAL_PARAMS.txLoss;
            document.getElementById('rx-loss-input').value = INITIAL_PARAMS.rxLoss;
        }

        function resetMeasurement() {
            overlay.setPosition(undefined);
            vectorSource.clear();
            points = [];
            if (elevationChart) { elevationChart.destroy(); elevationChart = null; }
            if (powerChart) { powerChart.destroy(); powerChart = null; }

            profileStatus.textContent = '2ç‚¹ç›®ã‚’å¾…ã£ã¦ã„ã¾ã™...';
            content.innerHTML = ''; // è¨ˆæ¸¬çµæœã‚’ã‚¯ãƒªã‚¢

            resetParameters();

            window.lastProfile = null;
            window.lastDistance = null;
            window.lastMaxElevation = null;
        }

        // drawElevationChart
        function drawElevationChart(profile, distanceMeters) {
            const ctx = document.getElementById('elevationChart').getContext('2d');
            const txHeightM = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeightM = parseFloat(document.getElementById('rx-height-input').value);
            const freqMHz = parseFloat(document.getElementById('freq-input').value);
            const txElev = profile[0].elevation + txHeightM;
            const rxElev = profile[profile.length - 1].elevation + rxHeightM;
            const effectiveEarthRadiusM = EARTH_RADIUS_M * K_FACTOR;
            const labels = profile.map(p => (p.distance / 1000).toFixed(2));
            const elevations = profile.map(p => p.elevation);
            const losLine = [];
            const f0_6Lower = [];

            profile.forEach(p => {
                const d1 = p.distance;
                const d2 = distanceMeters - d1;
                const bulge = (d1 * d2) / (2 * effectiveEarthRadiusM);
                const losAbsHeight = txElev + (rxElev - txElev) * (d1 / distanceMeters);

                losLine.push(losAbsHeight - bulge);

                const f1Radius = 17.32 * Math.sqrt((d1 * d2) / (freqMHz * distanceMeters));
                f0_6Lower.push(losAbsHeight - bulge - (0.6 * f1Radius));
            });

            const data = {
                labels: labels,
                datasets: [
                    {
                        label: 'åœ°å½¢æ¨™é«˜ (m)',
                        data: elevations,
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: 'start',
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.4,
                        order: 3
                    },
                    {
                        label: 'è¦‹é€šã—ç·š (LOS)',
                        data: losLine,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 3,
                        pointRadius: 0,
                        tension: 0,
                        order: 1
                    },
                    {
                        label: '0.6F1ä¸‹é™',
                        data: f0_6Lower,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        tension: 0,
                        order: 2
                    }
                ]
            };

            if (elevationChart) {
                elevationChart.data = data;
                elevationChart.options.scales.x.title.text = `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km`;
                elevationChart.update();
            } else {
                elevationChart = new Chart(ctx, {
                    type: 'line',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { title: { display: true, text: `è·é›¢ (km) - å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} km` } },
                            y: { title: { display: true, text: 'æ¨™é«˜ (m)' }, beginAtZero: false }
                        },
                        plugins: {
                            legend: { display: true, position: 'top' },
                            title: { display: false }
                        }
                    }
                });
            }
        }

        // drawPowerChart
        function drawPowerChart(propResults) {
            const ctx = document.getElementById('powerChart').getContext('2d');
            const txPowerW = parseFloat(document.getElementById('tx-power-input').value);
            const txGainDbi = parseFloat(document.getElementById('tx-gain-input').value);
            const rxGainDbi = parseFloat(document.getElementById('rx-gain-input').value);
            const txLossDb = parseFloat(document.getElementById('tx-loss-input').value);
            const rxLossDb = parseFloat(document.getElementById('rx-loss-input').value);

            if (propResults.error) {
                if (powerChart) powerChart.destroy(); powerChart = null;
                return;
            }

            // å„ã‚¹ãƒ†ãƒƒãƒ—ã®é›»åŠ›ãƒ¬ãƒ™ãƒ« (dBm) ã‚’è¨ˆç®—
            const txPowerDbm = W_TO_DBM(txPowerW);
            const afterTxLoss = txPowerDbm - txLossDb;
            const eirpDbm = afterTxLoss + txGainDbi;
            const afterPropLoss = eirpDbm - propResults.totalLossDb;
            const afterRxGain = afterPropLoss + rxGainDbi;
            const rxPowerDbm = afterRxGain - rxLossDb;

            const labels = [
                'é€ä¿¡æ©Ÿå‡ºåŠ›',
                'Txã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹',
                'Txç©ºä¸­ç·šåˆ©å¾— (EIRP)',
                'ä¼æ¬æå¤± (Rxã‚¢ãƒ³ãƒ†ãƒŠå…¥åŠ›)',
                'Rxç©ºä¸­ç·šåˆ©å¾—',
                'Rxã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹',
                'å—ä¿¡é›»åŠ›'
            ];

            const dataPoints = [
                txPowerDbm,       // 1. é€ä¿¡æ©Ÿå‡ºåŠ›
                afterTxLoss,      // 2. Txå´ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹å¾Œ
                eirpDbm,          // 3. Txå´ç©ºä¸­ç·šåˆ©å¾— (EIRP)
                afterPropLoss,    // 4. ä¼æ¬æå¤±å¾Œ (Rxã‚¢ãƒ³ãƒ†ãƒŠå…¥åŠ›)
                afterRxGain,      // 5. Rxå´ç©ºä¸­ç·šåˆ©å¾—å¾Œ
                rxPowerDbm,       // 6. Rxå´ã‚±ãƒ¼ãƒ–ãƒ«ãƒ­ã‚¹å¾Œ
                rxPowerDbm        // 7. å—ä¿¡é›»åŠ› (6ã¨åŒã˜ã ãŒã€æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•ã®çµ‚ç«¯ã¨ã—ã¦ç¢ºä¿)
            ];

            const data = {
                labels: labels,
                datasets: [{
                    label: 'é›»åŠ›ãƒ¬ãƒ™ãƒ« (dBm)',
                    data: dataPoints,
                    type: 'line',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.5)',
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                    fill: false,
                    tension: 0
                }]
            };

            if (powerChart) {
                powerChart.data = data;
                const minVal = Math.min(...dataPoints);
                const maxVal = Math.max(...dataPoints);
                powerChart.options.scales.y.min = Math.floor(minVal / 10) * 10 - 10;
                powerChart.options.scales.y.max = Math.ceil(maxVal / 10) * 10 + 10;

                powerChart.update();
            } else {
                powerChart = new Chart(ctx, {
                    type: 'line',
                    data: data,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: {
                                title: { display: true, text: 'ä¼æ¬çµŒè·¯ä¸Šã®è¦ç´ ' },
                                grid: { display: false }
                            },
                            y: {
                                title: { display: true, text: 'é›»åŠ›ãƒ¬ãƒ™ãƒ« (dBm)' },
                                beginAtZero: false
                            }
                        },
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: 'ä¼æ¬çµŒè·¯ ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ ', font: { size: 14 } },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2) + ' dBm';
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
            profileStatus.textContent = `${propResults.lossType}è¨ˆç®—å®Œäº†ã€‚å—ä¿¡é›»åŠ›: ${rxPowerDbm.toFixed(2)} dBm`;
        }

        /**
         * è¨ˆæ¸¬çµæœã®è¡¨ç¤ºï¼ˆåº§æ¨™ã€æ¨™é«˜ã€è·é›¢ã€ä¼æ¬è¨ˆç®—çµæœï¼‰
         */
        function displayMeasurementResults(coord1, coord2, dist, elev1, elev2, maxPoint, propResults = null) {
            const txHeight = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeight = parseFloat(document.getElementById('rx-height-input').value);

            let propHtml = '<h4>ä¼æ¬è¨ˆç®—çµæœ (ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æœªè¨ˆç®—)</h4><p>ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œã™ã‚‹ã«ã¯ã€ã„ãšã‚Œã‹ã®è¨ˆç®—ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p>';
            let losClass = '';

            if (propResults && !propResults.error) {
                if (propResults.lossType === "ITU-R (ã‚¹ã‚¿ãƒ–å€¤)") {
                    // ITUãƒ¢ãƒ¼ãƒ‰ã®è¡¨ç¤º
                     propHtml = `
                        <h4>ä¼æ¬è¨ˆç®—çµæœ (${propResults.lossType})</h4>
                        <p style="color: red;">âš ï¸ **æ³¨æ„:** ã“ã®çµæœã¯ã€ITU-R P.1546/P.1812ã‚’**ãƒ–ãƒ©ã‚¦ã‚¶ã§å³å¯†ã«è¨ˆç®—ã§ããªã„**ãŸã‚ã€FSPLã«ä»®ã®çµ±è¨ˆçš„æå¤± $+15 \text{ dB}$ ã‚’åŠ ãˆãŸ**ã€ã‚¹ã‚¿ãƒ–å€¤ã€‘**ã§ã™ã€‚</p>
                        <p><strong>FSPL (dB):</strong> ${propResults.freespaceLossDb.toFixed(2)} dB</p>
                        <p><strong>ç·æå¤± (dB):</strong> ${propResults.totalLossDb.toFixed(2)} dB</p>
                        <p><strong>å—ä¿¡é›»åŠ› (dBm):</strong> <strong style="color: ${propResults.rxPowerDbm > -80 ? 'green' : 'red'};">${propResults.rxPowerDbm.toFixed(2)} dBm</strong></p>
                    `;
                } else {
                    // ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«ã®è¡¨ç¤º
                    losClass = propResults.los ? 'los-yes' : 'los-no';
                    const losText = propResults.los ? 'è¦‹é€šã—ã‚ã‚Š (LOS)' : 'è¦‹é€šã—ãªã— (NLOS)';
                    const marginText = isNaN(propResults.minMarginMeters) ? 'N/A' : (propResults.minMarginMeters > 0 ? `${propResults.minMarginMeters.toFixed(1)} m (ç¢ºä¿)` : `${Math.abs(propResults.minMarginMeters).toFixed(1)} m (å¹²æ¸‰/é®è”½)`);
                    const rxPowerDbm = (propResults.rxPowerDbm !== null && propResults.rxPowerDbm !== undefined) ? propResults.rxPowerDbm : NaN;

                    propHtml = `
                        <h4>ä¼æ¬è¨ˆç®—çµæœ (${propResults.lossType})</h4>
                        <p><strong>è¦‹é€šã—åˆ¤å®š:</strong> <span class="${losClass}">${losText}</span></p>
                        <p><strong>æœ€å°F1ãƒãƒ¼ã‚¸ãƒ³:</strong> ${marginText}</p>
                        <p><strong>å›æŠ˜æå¤± (Ad):</strong> ${propResults.ad_loss.toFixed(2)} dB</p>
                        <p><strong>å…¨ä¼æ¬æå¤± (dB):</strong> ${propResults.totalLossDb.toFixed(2)} dB</p>
                        <p><strong>å—ä¿¡é›»åŠ› (dBm):</strong> <strong style="color: ${rxPowerDbm > -80 ? 'green' : 'red'};">${rxPowerDbm.toFixed(2)} dBm</strong></p>
                    `;
                }
            }

            const htmlContent = `
                <h4>è¨ˆæ¸¬ãƒ»åº§æ¨™æƒ…å ±</h4>
                <p><strong>2ç‚¹é–“è·é›¢:</strong> <strong style="color: blue;">${(dist / 1000).toFixed(3)} km</strong></p>
                <p><strong>æœ€é«˜æ¨™é«˜:</strong> <strong style="color: orange;">${maxPoint ? maxPoint.elevation.toFixed(1) + ' m' : 'N/A'}</strong></p>
                <hr>

                <table class="coord-table">
                    <thead>
                        <tr>
                            <th>é …ç›®</th>
                            <th>é€ä¿¡ç‚¹ (Tx)</th>
                            <th>å—ä¿¡ç‚¹ (Rx)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <th>ç·¯åº¦/çµŒåº¦ (WGS84)</th>
                            <td>${coord1[1].toFixed(5)}, ${coord1[0].toFixed(5)}</td>
                            <td>${coord2[1].toFixed(5)}, ${coord2[0].toFixed(5)}</td>
                        </tr>
                        <tr>
                            <th>MGRS</th>
                            <td>${convertToMGRS(coord1, 4)}</td>
                            <td>${convertToMGRS(coord2, 4)}</td>
                        </tr>
                        <tr>
                            <th>UTM</th>
                            <td>${convertToUTM(coord1)}</td>
                            <td>${convertToUTM(coord2)}</td>
                        </tr>
                        <tr>
                            <th>åœ°è¡¨é¢æ¨™é«˜ (m)</th>
                            <td>${elev1 !== null ? elev1.toFixed(1) + ' m' : 'N/A'}</td>
                            <td>${elev2 !== null ? elev2.toFixed(1) + ' m' : 'N/A'}</td>
                        </tr>
                        <tr>
                            <th>ç©ºä¸­ç·šé«˜ (m)</th>
                            <td>${txHeight.toFixed(1)} m</td>
                            <td>${rxHeight.toFixed(1)} m</td>
                        </tr>
                        <tr>
                            <th>çµ¶å¯¾é«˜ (m)</th>
                            <td>${elev1 !== null ? (elev1 + txHeight).toFixed(1) + ' m' : 'N/A'}</td>
                            <td>${elev2 !== null ? (elev2 + rxHeight).toFixed(1) + ' m' : 'N/A'}</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                ${propHtml}
            `;
            content.innerHTML = htmlContent;
        }

        // æ¨™é«˜ãƒ‡ãƒ¼ã‚¿å–å¾—ãƒ­ã‚¸ãƒƒã‚¯
        async function getElevation(coordinate) {
            const cacheKey = coordinate.map(c => c.toFixed(5)).join(',');
            if (elevationCache.has(cacheKey)) return elevationCache.get(cacheKey);

            const [lon, lat] = coordinate;
            const url = `${ELEVATION_API_URL}?lon=${lon}&lat=${lat}`;

            try {
                const response = await fetch(url, { signal: AbortSignal.timeout(API_TIMEOUT_MS) });
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                const elevation = data.elevation !== null && data.elevation !== undefined ? parseFloat(data.elevation) : null;
                elevationCache.set(cacheKey, elevation);
                return elevation;
            } catch (e) {
                console.warn(`Failed to fetch elevation for ${cacheKey}: ${e.message}`);
                elevationCache.set(cacheKey, null);
                return null;
            }
        }
        function interpolateCoordinates(coordA, coordB, fraction) {
            const lon = coordA[0] + (coordB[0] - coordA[0]) * fraction;
            const lat = coordA[1] + (coordB[1] - coordA[1]) * fraction;
            return [lon, lat];
        }

        async function getElevationProfile(coord1, coord2, maxSteps = DEFAULT_PROFILE_STEPS) {
            const distanceMeters = ol.sphere.getDistance(coord1, coord2);
            const steps = Math.max(10, Math.min(maxSteps, Math.ceil(distanceMeters / 100)));
            const profile = [];
            for (let i = 0; i <= steps; i++) {
                const fraction = i / steps;
                const coord = interpolateCoordinates(coord1, coord2, fraction);
                const elevation = await getElevation(coord);
                profile.push({ coord, webMercatorCoord: ol.proj.fromLonLat(coord), elevation, distance: distanceMeters * fraction });
            }
            return profile;
        }
        function findMaxElevationPoint(profile) {
            if (!profile || profile.length === 0) return null;
            let maxElev = -Infinity;
            let maxPoint = null;
            for (const p of profile) {
                if (p.elevation !== null && p.elevation > maxElev) {
                    maxElev = p.elevation;
                    maxPoint = p;
                }
            }
            return maxPoint;
        }
        function calculateCenterCoord(coord1, coord2) {
             return interpolateCoordinates(coord1, coord2, 0.5);
        }
        function addPointFeature(webMercatorCoord) {
            vectorSource.addFeature(new ol.Feature({ geometry: new ol.geom.Point(webMercatorCoord) }));
        }

        /**
         * ä¼æ¬æå¤±ã®è¨ˆç®— (ãƒŠã‚¤ãƒ•ã‚¨ãƒƒã‚¸å›æŠ˜ãƒ¢ãƒ‡ãƒ«ã‚’å°å…¥)
         */
        function calculatePropagation(profile, distanceMeters, calculationMode = 'simple') {
            if (!profile || profile.length < 2) return { los: false, freespaceLoss: NaN, clearance: NaN, rxPowerDbm: NaN, totalLossDb: NaN, error: "ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ä¸è¶³" };

            const freqMHz = parseFloat(document.getElementById('freq-input').value);
            const txHeightM = parseFloat(document.getElementById('tx-height-input').value);
            const rxHeightM = parseFloat(document.getElementById('rx-height-input').value);
            const txPowerW = parseFloat(document.getElementById('tx-power-input').value);
            const txGainDbi = parseFloat(document.getElementById('tx-gain-input').value);
            const rxGainDbi = parseFloat(document.getElementById('rx-gain-input').value);
            const txLossDb = parseFloat(document.getElementById('tx-loss-input').value);
            const rxLossDb = parseFloat(document.getElementById('rx-loss-input').value);

            if (isNaN(freqMHz) || isNaN(txHeightM) || isNaN(rxHeightM) || isNaN(txPowerW) || isNaN(txGainDbi) || isNaN(rxGainDbi) || isNaN(txLossDb) || isNaN(rxLossDb)) {
                 return { los: false, freespaceLoss: NaN, clearance: NaN, rxPowerDbm: NaN, totalLossDb: NaN, error: "ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™" };
            }

            const distKm = distanceMeters / 1000;
            const freespaceLossDb = 20 * Math.log10(distKm) + 20 * Math.log10(freqMHz) + 32.44;
            const txPowerDbm = W_TO_DBM(txPowerW);
            const eirpDbm = txPowerDbm - txLossDb + txGainDbi;

            if (calculationMode === 'itu') {
                // ğŸš¨ ITU-R P.1546/P.1812 ã®ã‚¹ã‚¿ãƒ–è¨ˆç®—
                // FSPLã«ä»®ã®çµ±è¨ˆçš„æå¤± (+15dB) ã‚’åŠ ç®—
                const stubTotalLossDb = freespaceLossDb + 15;
                const rxPowerDbm = eirpDbm - stubTotalLossDb + rxGainDbi - rxLossDb;

                return {
                    los: NaN,
                    ad_loss: 15, // ã‚¹ã‚¿ãƒ–å€¤
                    minClearanceRatio: NaN,
                    minMarginMeters: NaN,
                    freespaceLossDb: freespaceLossDb,
                    totalLossDb: stubTotalLossDb,
                    txPowerDbm: txPowerDbm,
                    rxPowerDbm: rxPowerDbm,
                    lossType: "ITU-R (ã‚¹ã‚¿ãƒ–å€¤)",
                    error: null
                };
            }

            // --- ç°¡æ˜“ãƒ¢ãƒ‡ãƒ« (Simple Mode) ã®è¨ˆç®— (å›æŠ˜ãƒ¢ãƒ‡ãƒ«é©ç”¨) ---
            const effectiveEarthRadiusM = EARTH_RADIUS_M * K_FACTOR;
            const txGroundElev = profile[0].elevation;
            const rxGroundElev = profile[profile.length - 1].elevation;
            const txElev = txGroundElev + txHeightM;
            const rxElev = rxGroundElev + rxHeightM;
            const wavelength = 300 / freqMHz * 1000000 / 1000000; // æ³¢é•· (m) (c/f)

            let totalLossDb = freespaceLossDb;
            let lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";

            let minMarginMeters = Infinity; // F1ã‚¾ãƒ¼ãƒ³ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ã‹ã‚‰ã®ãƒãƒ¼ã‚¸ãƒ³
            let deepestObstructionPoint = null; // æœ€ã‚‚é®è”½ãŒå³ã—ã„åœ°ç‚¹
            let maxV = -Infinity; //

            // LOS/F1åˆ¤å®šã¨é®è”½åœ°ç‚¹ã®ç‰¹å®šãƒ«ãƒ¼ãƒ—
            for (let i = 1; i < profile.length - 1; i++) {
                const p = profile[i];
                if (p.elevation === null) continue;

                const d1 = p.distance;
                const d2 = distanceMeters - d1;

                // åœ°çƒè†¨ã‚‰ã¿è£œæ­£ã•ã‚ŒãŸéšœå®³ç‰©é«˜ã•
                const bulge = (d1 * d2) / (2 * effectiveEarthRadiusM);
                const obstacleHeight = p.elevation + bulge;

                // è¦‹é€šã—ç·šã®çµ¶å¯¾é«˜ã•
                const losHeight = txElev + (rxElev - txElev) * (d1 / distanceMeters);

                // ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ H (LOSã‹ã‚‰ã®é®è”½é‡ã€‚LOSã‚ˆã‚Šä¸‹ãªã‚‰è² )
                const clearanceH = losHeight - obstacleHeight;

                // F1ã‚¾ãƒ¼ãƒ³åŠå¾„
                const f1Radius = 17.32 * Math.sqrt((d1 * d2) / (freqMHz * distanceMeters));

                // F1ãƒãƒ¼ã‚¸ãƒ³
                const f1Margin = clearanceH - f1Radius;
                minMarginMeters = Math.min(minMarginMeters, f1Margin);

                // å›æŠ˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ v ã®è¨ˆç®—
                if (d1 > 0 && d2 > 0 && distanceMeters > 0) {
                    const v = clearanceH * Math.sqrt(2 / wavelength * (1/d1 + 1/d2));

                    if (deepestObstructionPoint === null || (v < 0 && v < deepestObstructionPoint.v)) {
                         // vãŒè² ã§ã€ã‚ˆã‚Šå°ã•ã„ï¼ˆæ·±ã„é®è”½ï¼‰åœ°ç‚¹ã‚’ç‰¹å®š
                        deepestObstructionPoint = { v, d1, d2, clearanceH, f1Radius };
                    }
                    if (v > 0 && v > maxV) { // LOSã§æœ€ã‚‚ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ãŒå¤§ãã„åœ°ç‚¹ã‚’ãƒˆãƒ©ãƒƒã‚¯ (vãŒæ­£)
                         maxV = v;
                    }
                }
            }

            let los = (minMarginMeters > 0);
            let ad_loss = 0; // å›æŠ˜æå¤±

            if (los) {
                // å®Œå…¨ã«LOSã®å ´åˆ
                lossType = "è‡ªç”±ç©ºé–“æå¤± (FSPL)";
                // F1ã‚¾ãƒ¼ãƒ³ã®0.6ä»¥ä¸‹ã®ä¾µå…¥ãŒã‚ã‚Œã°ã€è»½å¾®ãªæå¤±ã‚’åŠ ç®— (æ—§ãƒ­ã‚¸ãƒƒã‚¯ã®åæ®‹ã§ã€ã»ã¼FSPL)
                if (minMarginMeters < (1 - 0.6) * deepestObstructionPoint?.f1Radius) {
                    ad_loss = 3;
                    lossType = "FSPL + è»½å¾®ãªå›æŠ˜æå¤±";
                }
            } else {
                // é®è”½ãŒã‚ã‚‹å ´åˆ: æœ€ã‚‚å³ã—ã„åœ°ç‚¹ã§ãƒŠã‚¤ãƒ•ã‚¨ãƒƒã‚¸å›æŠ˜æå¤±ã‚’è¨ˆç®—
                if (deepestObstructionPoint) {
                    const v = deepestObstructionPoint.v;

                    // ITU-R P.526-10 (4) ã®è¿‘ä¼¼å¼ã‚’å‚è€ƒã«ã—ãŸå›æŠ˜æå¤±è¨ˆç®—
                    if (v > -0.78) {
                        // v > -0.78 ã®ã¨ã: Ad(v) = 6.9 + 20*log10(sqrt((v-0.1)^2+1) + v - 0.1)
                        ad_loss = 6.9 + 20 * Math.log10(Math.sqrt(Math.pow(v - 0.1, 2) + 1) + v - 0.1);
                    } else {
                        // v <= -0.78 ã®ã¨ã: ã‚ˆã‚Šæ·±ã„å›æŠ˜
                        // vãŒæ¥µç«¯ã«è² ï¼ˆæ·±ã„é®è”½ï¼‰ã®å ´åˆã®è¿‘ä¼¼
                        ad_loss = 20 * Math.log10(0.225 / Math.abs(v));
                        // çµŒé¨“çš„ãªæœ€å¤§æå¤±ã‚’é©ç”¨ã—ã€éå‰°ãªå›æŠ˜æå¤±ã‚’é˜²ãï¼ˆä¾‹: 50dBã‚’ä¸Šé™ï¼‰
                        ad_loss = Math.min(ad_loss, 50);
                    }

                    totalLossDb += ad_loss;
                    lossType = `FSPL + å›æŠ˜æå¤± (${ad_loss.toFixed(1)} dB) ğŸš§`;

                } else {
                    // ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ç‰¹æ®Šã‚±ãƒ¼ã‚¹ï¼ˆè·é›¢ãŒçŸ­ã™ãã‚‹ã€ãƒ‡ãƒ¼ã‚¿æ¬ æãªã©ï¼‰
                    totalLossDb += 30;
                    ad_loss = 30;
                    lossType = "FSPL + é®è”½æå¤± (å›ºå®šãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)";
                    los = false;
                }
            }

            totalLossDb += ad_loss; // FSPL + å›æŠ˜æå¤±

            const rxPowerDbm = eirpDbm - totalLossDb + rxGainDbi - rxLossDb;

            return {
                los: los,
                ad_loss: ad_loss, // æ–°è¦è¿½åŠ 
                minClearanceRatio: minMarginMeters / deepestObstructionPoint?.f1Radius || NaN,
                minMarginMeters: minMarginMeters,
                freespaceLossDb: freespaceLossDb,
                totalLossDb: totalLossDb,
                txPowerDbm: txPowerDbm,
                rxPowerDbm: rxPowerDbm,
                lossType: lossType
            };
        }

        /**
         * ãƒ¡ã‚¤ãƒ³ã®è¨ˆæ¸¬å‡¦ç†ï¼ˆåœ°å›³ã‚¯ãƒªãƒƒã‚¯æ™‚ï¼‰
         */
        async function processMeasurement() {
            if (!points || points.length < 2) return;

            profileStatus.classList.add('progress');
            profileStatus.textContent = 'æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ä¸­...';
            const [coord1, coord2] = points;

            const lineFeature = new ol.Feature({ geometry: new ol.geom.LineString([ol.proj.fromLonLat(coord1), ol.proj.fromLonLat(coord2)]) });
            vectorSource.addFeature(lineFeature);

            const profile = await getElevationProfile(coord1, coord2, DEFAULT_PROFILE_STEPS);

            if (!profile || profile.length < 2) {
                profileStatus.classList.remove('progress');
                profileStatus.textContent = 'ã‚¨ãƒ©ãƒ¼: æ¨™é«˜ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚';
                alert('æ¨™é«˜ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ™‚é–“ã‚’ãŠã„ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚');
                window.lastProfile = null;
                return;
            }

            const maxElevationPoint = findMaxElevationPoint(profile);
            if (maxElevationPoint) {
                const maxElevFeature = new ol.Feature({ geometry: new ol.geom.Point(maxElevationPoint.webMercatorCoord), type: 'max_elevation' });
                vectorSource.addFeature(maxElevFeature);
            }

            const distanceMeters = ol.sphere.getDistance(coord1, coord2);

            // ä¼æ¬è¨ˆç®—çµæœã¯nullã§è¡¨ç¤ºï¼ˆãƒœã‚¿ãƒ³æŠ¼ä¸‹å¾…ã¡ï¼‰
            displayMeasurementResults(coord1, coord2, distanceMeters, profile[0].elevation, profile[profile.length - 1].elevation, maxElevationPoint, null);
            drawElevationChart(profile, distanceMeters);

            // ãƒ¬ãƒ™ãƒ«ãƒ€ã‚¤ãƒ¤ã‚°ãƒ©ãƒ ã¯ã‚¯ãƒªã‚¢ã—ã¦ãŠã
            if (powerChart) { powerChart.destroy(); powerChart = null; }

            const lonLatCenterCoord = calculateCenterCoord(coord1, coord2);
            const webMercatorCenterCoord = ol.proj.fromLonLat(lonLatCenterCoord);
            adjustOverlayPosition(overlay, webMercatorCenterCoord);

            profileStatus.classList.remove('progress');
            profileStatus.textContent = `è¨ˆæ¸¬å®Œäº†ã€‚å…¨é•·: ${(distanceMeters / 1000).toFixed(3)} kmã€‚ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚`;

            window.lastProfile = profile;
            window.lastDistance = distanceMeters;
            window.lastMaxElevation = maxElevationPoint;
        }

        /**
         * ä¼æ¬è¨ˆç®—ã¨ã‚°ãƒ©ãƒ•ã®æ›´æ–°å‡¦ç† (çµ±åˆ)
         */
        function executeRecalculation(mode) {
            if (!window.lastProfile || !window.lastDistance) {
                alert('å…ˆã«åœ°å›³ä¸Šã§2ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
                return;
            }

            profileStatus.classList.add('progress');
            profileStatus.textContent = `${mode === 'simple' ? 'ç°¡æ˜“ãƒ¢ãƒ‡ãƒ«' : 'ITU-R'}ã§ä¼æ¬è¨ˆç®—ã‚’å®Ÿè¡Œä¸­...`;

            const [coord1, coord2] = points;

            const propResults = calculatePropagation(window.lastProfile, window.lastDistance, mode);

            if (propResults.error) {
                alert(`ä¼æ¬è¨ˆç®—ã‚¨ãƒ©ãƒ¼: ${propResults.error}`);
                profileStatus.classList.remove('progress');
                profileStatus.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚';
                return;
            }

            displayMeasurementResults(
                coord1,
                coord2,
                window.lastDistance,
                window.lastProfile[0].elevation,
                window.lastProfile[window.lastProfile.length - 1].elevation,
                window.lastMaxElevation,
                propResults
            );

            // æ¨™é«˜æ–­é¢å›³ã¯ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¤‰ã‚ã£ã¦ã‚‚åœ°å½¢ã¯å¤‰ã‚ã‚‰ãªã„ã®ã§å†æç”»ã¯ä¸è¦ã ãŒã€å¿µã®ãŸã‚ã€‚
            drawElevationChart(window.lastProfile, window.lastDistance);
            drawPowerChart(propResults);

            profileStatus.classList.remove('progress');
            profileStatus.textContent = `${propResults.lossType}è¨ˆç®—å®Œäº†ã€‚å—ä¿¡é›»åŠ›: ${propResults.rxPowerDbm.toFixed(2)} dBm`;

            if (mode === 'itu') {
                 // ITUè¨ˆç®—ã®é›£ã—ã•ã«é–¢ã™ã‚‹ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å‡ºã™
                alert("ã€ITU-R P.1546/P.1812 è¨ˆç®—ã«ã¤ã„ã¦ã€‘\n\nã“ã‚Œã‚‰ã®ãƒ¢ãƒ‡ãƒ«ã¯ã€å¤§è¦æ¨¡ãªåœ°å½¢ãƒ‡ãƒ¼ã‚¿ã‚„çµ±è¨ˆçš„ãƒ‡ãƒ¼ã‚¿ã€è©³ç´°ãªç’°å¢ƒãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¿…è¦ã¨ã—ã¾ã™ã€‚\n\nãƒ–ãƒ©ã‚¦ã‚¶å´ã®JavaScriptã§å³å¯†ã«è¨ˆç®—ã™ã‚‹ã“ã¨ã¯ä¸å¯èƒ½ãªãŸã‚ã€ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹çµæœã¯ã€FSPLã«çµ±è¨ˆçš„æå¤±ã‚’ä»®å®šã—ãŸã€ã‚¹ã‚¿ãƒ–ï¼ˆä»®ã®å€¤ï¼‰ã€‘ã§ã™ã€‚\n\nè©³ç´°ãªITUè¨ˆç®—ã«ã¯ã€å°‚ç”¨ã®ã‚µãƒ¼ãƒãƒ¼å´è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ ãŒå¿…è¦ã§ã™ã€‚");
            }
        }


        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ä½ç½®èª¿æ•´é–¢æ•°ï¼ˆåœ°å›³ä¸Šã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç”¨ï¼‰
        function adjustOverlayPosition(overlay, coord) {
            const pixel = map.getPixelFromCoordinate(coord);
            const mapSize = map.getSize();
            const overlayElement = overlay.getElement();
            const overlayWidth = overlayElement.offsetWidth;
            const overlayHeight = overlayElement.offsetHeight;
            pixel[0] = Math.max(overlayWidth / 2, Math.min(pixel[0], mapSize[0] - overlayWidth / 2));
            pixel[1] = Math.max(overlayHeight, Math.min(pixel[1], mapSize[1] - overlayHeight / 2));
            const adjustedCoord = map.getCoordinateFromPixel(pixel);
            overlay.setPosition(adjustedCoord);
        }

        // å†è¨ˆç®—ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        document.getElementById('simple-recalculate-btn').addEventListener('click', () => executeRecalculation('simple'));
        document.getElementById('itu-calculate-btn').addEventListener('click', () => executeRecalculation('itu'));

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (ãƒ‰ãƒ©ãƒƒã‚°ã€ã‚¯ãƒªãƒƒã‚¯ãªã©)
        popupHeader.addEventListener('mousedown', event => startDrag(event, container));
        profileHeader.addEventListener('mousedown', event => startDrag(event, profileContainer));
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('mouseup', stopDrag);
        popupHeader.addEventListener('touchstart', event => startDrag(event, container), { passive: false });
        profileHeader.addEventListener('touchstart', event => startDrag(event, profileContainer), { passive: false });
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        document.addEventListener('touchend', stopDrag);
        closer.onclick = function() { resetMeasurement(); return false; };

        profileCloser.onclick = function() {
            profileContainer.style.display = 'none';
            return false;
        };
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¤ãƒ™ãƒ³ãƒˆ
        document.addEventListener('change', function(event) {
            if (event.target.name === 'base_type' || event.target.name === 'tile_source') {
                const baseType = document.querySelector('input[name="base_type"]:checked').value;
                const tileSource = document.querySelector('input[name="tile_source"]:checked').value;
                baseLayerGroup.getLayers().forEach(layer => layer.setVisible(false));
                if (baseType === 'std') {
                    if (tileSource === 'osm') osmLayer.setVisible(true);
                    else if (tileSource === 'gsi') gsiStdLayer.setVisible(true);
                } else if (baseType === 'photo') gsiPhotoLayer.setVisible(true);
            }
        });

        map.on('click', async (evt) => {
            const webMercatorCoord = evt.coordinate;
            const lonLatCoord = ol.proj.toLonLat(webMercatorCoord);
            overlay.setPosition(undefined);
            if (points.length >= 2) resetMeasurement();
            addPointFeature(webMercatorCoord);
            points.push(lonLatCoord);

            profileContainer.style.display = 'flex';

            if (points.length === 2) {
                await processMeasurement();
            } else {
                profileStatus.textContent = '2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨ˆæ¸¬ã‚’å®Œäº†ã—ã¦ãã ã•ã„ã€‚';
            }
        });

        // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«æ–­é¢å›³ã‚’éè¡¨ç¤ºã«ã—ã¦ãŠã
        window.onload = () => {
            profileContainer.style.display = 'none';
        };

    </script>
</body>
</html>
